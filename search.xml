<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[汇编指令整理]]></title>
    <url>%2F2020%2F01%2F15%2Fasm-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[TL;DR 汇编寄存器整理1. 通用数据传送指令12345678910111213141516MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点, AL为表的索引值(0-255,即0-FFH); 返回AL为查表结果.([BX+AL]-&gt;AL) 2. 输入输出端口传送指令:1234IN I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; ) OUT I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 ) 输入输出端口由立即方式指定时,其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 3. 目的地址传送指令:123456LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令:123456LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈. 算术运算指令1234567891011121314151617181920212223242526272829ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. 逻辑运算指令1234567891011121314151617AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL 串指令1234567891011MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中. ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. 无条件转移指令 (长转移)123JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )1234567891011121314151617181920JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移. 循环控制指令(短转移)12345LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 中断指令123INT 中断指令 INTO 溢出中断 IRET 中断返回 处理器控制指令123456789101112HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. 伪指令1234567DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束. 处理机控制指令：标志处理指令123456789101112CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 浮点运算指令集控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)1234567891011121314151617181920212223FINIT 初始化浮点部件 9B DB E3 FCLEX 清除异常 9B DB E2 FDISI 浮点检查禁止中断 9B DB E1 FENI 浮点检查禁止中断二 9B DB E0 WAIT 同步CPU和FPU 9B FWAIT 同步CPU和FPU D9 D0 FNOP 无操作 DA E9 FXCH 交换ST(0)和ST(1) D9 C9 FXCH ST(i) 交换ST(0)和ST(i) D9 C1iii FSTSW ax 状态字到ax 9B DF E0 FSTSW word ptr mem 状态字到mem 9B DD mm111mmm FLDCW word ptr mem mem到状态字 D9 mm101mmm FSTCW word ptr mem 控制字到mem 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 D9 mm100mmm FSTENV word ptr mem 全环境到mem 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 DD mm100mmm FSAVE word ptr mem FPU状态到mem 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 D9 F7 FSETPM 浮点设置保护 DB E4 数据传送指令123456789101112131415161718192021222324252627282930313233343536373839404142FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii 比较指令12345678910111213141516FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 运算指令1234567891011121314151617181920212223242526272829303132333435363738394041424344FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器， 而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何， 经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器， 来源操作数必须是字组整数或短整数形态的变数 FSUB 减 FSUBP FSUBR 减数与被减数互换 FSUBRP FISUB FISUBR FMUL 乘 FMULP FIMUL FDIV 除 FDIVP FDIVR FDIVRP FIDIV FIDIVR FCHS 改变 ST 的正负值 FABS 把 ST 之值取出，取其绝对值后再存回去。 FSQRT 将 ST 之值取出，开根号后再存回去。 FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入ST里，而 ST(1)之值不变 ST(1)必须是在 -32768 到 32768(-215到215)之间的整数， 如果超过这个范围计算结果无法确定，如果不是整数ST(1)会先向零舍入成整数 再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。 FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU提供四种舍入方式， 由 FPU 的控制字组(control word)中的RC两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>asm</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroService Part.1, 认识Go-Micro]]></title>
    <url>%2F2019%2F07%2F11%2Fgo-micro-part-1%2F</url>
    <content type="text"><![CDATA[TL;DR12参考地址https://micro.mu/docs/cn/index.html Part.1micro由以下几个部分组成： API网关（API Gateway）： - API Gateway 网关。API网关是请求的入口，把请求动态路由到具体服务。网关允许我们建立可伸缩的后台微服务架构，并且让工作在前端的公共API更健壮。Micro API基于服务发现拥有强大的路由能力，通过我们预置的handlers插件，它可以处理http、gRPC、websocket、消息推送事件等等。 命令行接口（Interactive CLI）： 交互式的命令行接口。CLI通过终端可以描述、查询、直接与平台和服务进行交互。CLI提供所有的命令让开发者明白微服务正在处理的事情。CLI也包含了交互模式。 服务代理（Service Proxy）： 服务代理，基于Go Micro和MUCP协议构建的透明的代理服务。它将服务发现、负载均衡、消息编码、中间件、传输及代理插件转移到某一（具体服务所在）位置，同api不同，它不暴露任何接口，只工作在内部环境，相当于桥接内部服务。 模板生成（Template Generation）： 基于模板快速创建新的服务代码。Micor提供预置的模板，通过模板编写统一风格的代码。 SlackOps小机器人（SlackOps Bot）： Slack小机器人插件，当它运行中服务中时，这个插件允许开发者通过Slack消息来操作平台。MicroBot插件提供聊天配置选项，这样就可以让团队通过向小机器人发送聊天消息来做一些我们希望它做的事，这里面当然也包含像动态发现服务一样创建slack命令。 管理控制台（Web Dashboard）： 通过Web管理控制台，可以直接在Web页面上查看服务的运行情况，展示端点信息，请求与响应状态，甚至直接向服务进行查询。管理控制台也有CLI交互页面提供给开发者在线上处理，就像直接操作终端一样。 Go-micro框架（Go Framework）： Go Micro框架是Micro的底层、核心。GO-Micro把分布式服务抽象，并提供简便的方式让大家构建具有高弹性的微服务。]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang Part.2, 语法第一步 + 程序员的一小步]]></title>
    <url>%2F2019%2F07%2F11%2Fgolang-golang-3%2F</url>
    <content type="text"><![CDATA[TL;DR Part.2, 语法第一步 + 程序员的一小步创建hello.go注释很重要，请看完再说！1234567891011// 每一个 Go 文件都应该在开头进行 package name 的声明package main// 引入了 fmt 包，用于在 main 函数里面打印文本到标准输出import &quot;fmt&quot;// main 是一个特殊的函数。整个程序就是从 main 函数开始运行的func main() &#123; // fmt 包中的 Println 函数用于把文本写入标准输出 fmt.Println(&quot;Hello World&quot;)&#125; 运行运行的方式有多种 go run 命令运行 go run hello.go go install go install hello， 如果加入环境变量则可以 ./hello 运行编译后的程序 如果没有 $GOPATH/bin/hello 运行即可 go playground 运行 进阶用法. 变量上面已经说过该如何编写第一个程序，但是上面只是简易的打印了一个字符串，实际应用中需要许多的变量存储交换数据 变量是什么 变量指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。在 Go 中，有多种语法用于声明变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;func main() &#123; var money int // 变量声明 fmt.Println(&quot;my money &quot;, money) // 改变值，发工资了 money = 1000 fmt.Println(&quot;my money&quot;, money) // 再次改变值，工资花出去了 交500块房租 money -= 500 fmt.Println(&quot;my money&quot;, money) // 一个月吃饭 money -= 500 fmt.Println(&quot;my money&quot;, money) // 还没到月底，钱花完了，先借支吧 var BorrowMoney int = 1000 fmt.Println(&quot;my money&quot;, BorrowMoney) // 奖金 有时候不清楚发的是钱，还是梦想，所以让上天决定吧 var JiangJin = 100 fmt.Println(&quot;my JiangJin&quot;, JiangJin) // KPI 绩效100 提成200 var KPI, TC int = 100, 200 fmt.Println(&quot;KPI is&quot;, KPI, &quot;TC is&quot;, TC) // 聚餐AA了 var ( aa1_name = &quot;xiaoming&quot; aa1_money = 200 ) fmt.Println(&quot;my name is&quot;, aa1_name, &quot;, Pay moeny&quot;, aa1_money) aa2_name, aa2_money := &quot;XM&quot;, 200 fmt.Println(&quot;my name is&quot;, aa2_name, &quot;, Pay moeny&quot;, aa2_money)&#125; 最终结果是 123456789my money 0my money 1000my money 500my money 0my money 1000my JiangJin 100KPI is 100 TC is 200my name is xiaoming , Pay moeny 200my name is XM , Pay moeny 200 可以看出来月光族很惨]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 安装和配置]]></title>
    <url>%2F2019%2F07%2F10%2Fgolang-golang-2%2F</url>
    <content type="text"><![CDATA[TL;DR 安装 Mac 安装brew install go 设置环境变量12345678export GOPATH=/Volumes/Data/gopathexport GOROOT=/usr/local/opt/go/libexec# 开启go mod 模式 下一章节会说到export GO111MODULE=onexport PATH=&quot;$PATH:$GOPATH/bin:$GOROOT/bin&quot;#此处为go get 代理，但是并没有什么卵用#export GOPROXY=https://goproxy.ioexport GOPROXY= 代理问题上面说到GOPROXY没有什么卵用，还是经常网络掉包什么的这里推荐几个方式proxifer 强制全局走代理 or 1proxychains4 go get -u github.com/swaggo/swag 参考链接Mac OSX 终端走 shadowsocks 代理 Proxifier+Shadowshocks系统全局代理的正确姿势]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang Part.1 包管理器]]></title>
    <url>%2F2019%2F03%2F31%2Fgolang-golang-1%2F</url>
    <content type="text"><![CDATA[TL;DR Part.1, Golang Modulesgo modgo building package manager. go mod是go语言内置的包管理工具，集成在go tool中，安装好go就可以使用。 要求: go version &gt;= 1.11 官方文档： https://tip.golang.org/cmd/go… 环境变量12345678910# 通过环境变量GOPROXY设置代理export GOPROXY=https://goproxy.ioORproxychains4 go get github.com/shirou/gopsutil/disk# go mod功能开关，默认是auto，在gopath中不启用# 可设置为on强制启用export GO111MODULE=on 初始化 go mod initinit报错outside gopath no import comments 12345# 方法一 手动创建go.mod文件， 写入module xxxecho &apos;module xxx&apos; &gt; go.mod# 方法二 main包加入import声明package main // import &quot;xxx&quot; go mod download下载依赖 go mod tidy同步依赖包，添加需要的，移除多余的 go mod vendor将依赖包放入vendor go get 下载/升级依赖go mod不再下载源码进$GOPATH/src go mod的下载目录在$GOPATH/pkg/mod，并且是文件权限是只读的-r--r--r-- 12# tag必须以v开头 v1.2.3格式go get -u xxx.com/pkg@2.1.0 vendor 模式go mod是不推荐使用vendor目录的，而是直接使用source或cache中的包。 在根目录有vendor文件夹时默认使用vendor模式。此模式下依赖只从vendor中找。 https://github.com/golang/go/… 1234567# vendor模式下get报错：go get: disabled by -mod=vendor# mod有三个取值# mod can be &apos;&apos;, &apos;readonly&apos;, or &apos;vendor&apos;# 两种赋值方式都可以-mod=&apos;&apos;-mod &apos;&apos; replace让原本依赖的 github.com/repo/pkg 包，实际使用 github.com/your-fork/pkg@version。 1go mod edit -replace github.com/repo/pkg=github.com/your-fork/pkg@version 清缓存go clean -modcache go.mod &amp; go.sumgo.mod：依赖列表和版本约束。 go.sum：记录module文件hash值，用于安全校验。 最佳实践go mod不推荐使用vendor，不要将vendor提交到版本控制。 提交go.mod，可以忽略go.sum，因为会根据校验sum跨平台可能报错。]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言汇编解释-1]]></title>
    <url>%2F2019%2F03%2F31%2Fclang-cinasm-1%2F</url>
    <content type="text"><![CDATA[TL;DR本文转载自 github冻死胖子-github1所用示例均为翻新，有 参考《Linux C编程一站式学习》以及冻死胖子的Github，如有版权问题，请联系站长删除 本教程使用的编译器为：12345➜ ~ clang -vApple LLVM version 10.0.1 (clang-1001.0.46.3)Target: x86_64-apple-darwin18.5.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin Show Me The Code老规矩，万物之本 打印 HelloWorld123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\n&quot;); return 0;&#125; 代码写好了，如何运行呢， 命令如下，生成.out可执行文件123456789101112➜ CinASM clang Hello.c ➜ CinASM ls -la total 40drwxr-xr-x 7 lookwi staff 238 Mar 31 18:40 .drwxr-xr-x@ 14 lookwi staff 476 Mar 31 18:32 ..drwxr-xr-x 7 lookwi staff 238 Mar 31 18:39 .idea-rw-r--r-- 1 lookwi staff 109 Mar 31 18:33 CMakeLists.txt-rwxr-xr-x 1 lookwi staff 8432 Mar 31 18:40 a.outdrwxr-xr-x 7 lookwi staff 238 Mar 31 18:33 cmake-build-debug-rw-r--r-- 1 lookwi staff 79 Mar 31 18:33 main.c➜ CinASM ./a.out Hello, World! 说好的ASM123456789101112131415161718192021222324252627282930313233➜ CinASM clang -S main.c➜ CinASM cat main.s .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 14 sdk_version 10, 14 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc # 指定入口函数## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp movl $0, -4(%rbp) leaq L_.str(%rip), %rdi movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot;.subsections_via_symbols 解释之前还是说一下汇编基础表关于寄存器CS（Code Segment）：代码段寄存器DS（Data Segment）：数据段寄存器SS（Stack Segment）：堆栈段寄存器ES（Extra Segment）：附加段寄存器当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS, ES esi，edi，分别是16位寄存器DI和SI的32位扩展。它们是源变址寄存器，和目的变址寄存器，用于串操作指令中。同时，它们也可以作为通用寄存器使用。 EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。EDX 则总是被用来放整数除法产生的余数。 常用寄存器有16个，分为x86通用寄存器以及r8-r15寄存器。 通用寄存器中，函数执行前后必须保持原始的寄存器有3个：是rbx、rbp、rsp。rx寄存器中，最后4个必须保持原值：r12、r13、r14、r15。保持原值的意义是为了让当前函数有可信任的寄存器，减小在函数调用过程中的保存&amp;恢复操作。除了rbp、rsp用于特定用途外，其余5个寄存器可随意使用。 通用寄存器中，不必假设保存值可随意使用的寄存器有5个：是rax、rcx、rdx、rdi、rsi。其中rax用于第一个返回寄存器（当 然也可以用于其它用途），rdx用于第二个返回寄存器（在调用函数时也用于第三个参数寄存器）。rcx用于第四个参数。rdi用于第一个参数。rsi用于 第二个函数参数。 r8、r9分配用于第5、第6个参数。 这里需要说明的是因为实验环境为Darwin内核，因此许多汇编代码是不同的大致可分为两种不同的类型 DOS/Windows (Intel 风格) Unix 和 Linux 系统 ( AT&amp;T 风格) table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 20% ; } table th:nth-of-type(3){ width: 20%; } table th:nth-of-type(4){ width: 40%; } AT&amp;T 格式 Intel 格式 解释 区别 pushl %eax push eax 在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀 pushl $1 push 1 在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。 addl $1, %eax add eax, 1 AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边 movb val, %al mov al, byte ptr val 在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的 ljump $section, $offset jmp far section:offset 在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上’*’作为前缀，而在 Intel 格式中则不需要 lcall $section, $offset call far section:offset 远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 “ljump” 和 “lcall”，而在 Intel 汇编格式中则为 “jmp far” 和 “call far” lret $stack_adjust ret far stack_adjust 与（jump/call）相应的远程返回指令 解释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374➜ CinASM clang -S main.c➜ CinASM cat main.s .section __TEXT,__text,regular,pure_instructions ## 编译器指令 告知编译器相关的信息或者进行特定操作 ## __TEXT,__text用来存放代码指令, 代码一般都放在这一节 ## regular：regular类型的节区可以包含任意代码或数据，并且链接器不会对它们进行任何特殊处理。 .build_version macos, 10, 14 sdk_version 10, 14 ## 编译信息 .globl _main ## -- Begin function main ## .global关键字用来让一个符号对链接器可见，可以供其他链接对象模块使用。 ## .global _main 让 _main 符号成为可见的标示符，这样链接器就知道跳转到程序中的什么地方并开始执行。 .p2align 4, 0x90 ## 将位置计数器（在当前子部分中）填充到特定存储边界_main: ## @main .cfi_startproc # Main 函数开始 # 用在每个函数的开始，用于初始化一些内部数据结构## %bb.0: pushq %rbp # 保存旧的帧指针，相当于创建新的栈帧 .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 ## CFI 指令 movq %rsp, %rbp ## 指令则将rsp寄存器的值赋值给rbp寄存器．这样一来，属于main函数的栈区域便构建好了． .cfi_def_cfa_register %rbp # CFI 指令 修改计算CFA的规则。从现在开始，将使用寄存器而不是旧寄存器。 偏移量保持不变 subq $16, %rsp # 也就是rsp = rsp - 16 将栈地址减去16, 用于存放局部变量 movl $0, -4(%rbp) # 将0存放于rbp - 4的值作为指针指向的内存地址, 也就是栈顶下方4 byte位置, 从后面的代码中推测出这里存放的是main方法的默认返回值0 leaq L_.str(%rip), %rdi # 指令引用了L_.str这个标签, 在经过汇编器汇编后会将标汇编为字符串所存放的地址, 让程序可以定位到字符串. 首先lea指令是mov指令的变种，据说，lea指令是x86体系结构中，是一条最古老但是从某个方面来讲又是最神奇的指令。 表面上看，它做的事情非常简单，根据括号里的源操作数来计算地址，然后把地址加载到目标寄存器中。 上面的操作就是 先计算地址 L_.str(%rip) 然后把最终地址载到寄存器 rdi 中 movb $0, %al # 把 0 值传送给32为的EAX寄存器值 callq _printf # 调用 printf 函数 将下一条指令的地址入栈，然后跳转到目标地址处执行 指令callq _printf将%rdi作为第一个参数(里面存放的是&quot;hello, world\n&quot;字符串的地址)调用_printf方法 ### 方法尾(epilogue), 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置 xorl %ecx, %ecx # 将ecx 计数器 置零咯 movl %eax, -8(%rbp) ## 4-byte Spill # movl是以寄存器运算结果为游标，访问内存获得该地址的值，然后给目标寄存器赋值 movl %ecx, %eax addq $16, %rsp popq %rbp # 从 RBP 寄存器栈中取出数据 retq ### 方法尾(epilogue), 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置 .cfi_endproc # Main 函数结束 #.cfi_startproc 和 .cfi_endproc 分别是 dwarf2 CFI 的初始过程和结束过程指 ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot; # 分配一段字符串内存单元，并用expr初始化字符串内存单元.subsections_via_symbols 解释完了，有什么不对的地方，欢迎留言给我，请多多指教]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>汇编</tag>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造高效的PHP工作环境]]></title>
    <url>%2F2016%2F01%2F01%2FPHP-%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E7%9A%84PHP%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[用了一段时间的Mac系统， 记录一下使用心得在使用大多数环境时，为了偷懒更加偏向于Homebrew的依赖安装，省去了自己编译的方法，所以在开始的时候呢，首先说一下翻墙环境我使用的是SS + kcptun 的模式，由于大部分操作都是在终端环境，所以这里先来一个Proxy代理的方案 利器代理篇12345678910111213// 在终端中输入如下命令行export all_proxy=socks5://127.0.0.1:1080// 也可以分开TLS 和 HTTP访问export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;// git 操作 一般情况下访问国外才需要这么做，访问国内时可以切换回来，// 我也懒得改，反正是kcptun加速，也没有感觉git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global --unset http.proxygit config --global --unset https.proxy 如果你不想这么麻烦，可以选择 Proxifier 全局代理，当然在大多数情况下，有些软件不支持代理的话，可以选择 Proxifier 进行强制代理 Proxifier 下载地址 当然你还可能会遇到，只支持HTTP代理的，那么可以选择 privoxy 将 socks5转换成HTTP 但我个人很少使用这种方式 利器浏览器篇当有了代理之后，SS如果选择全局代理的话感觉也不是很好可以走PAC，但我个人选择SwitchyOmega这里就不啰嗦了，推荐几个我觉得好用的 FeHelper 百度开发的Web前端助手 Adblock Plus 广告屏蔽，虽然没以前好用了，但是也还不错用习惯了 Octotree Github 浏览目录结构利器 Sourcegraph 比上面的强大的代码阅读理解工具 利器安装包篇有了代理之后，可以愉快的下载到各种你下载慢的东西了，比如说composer, npm i, git, docker等等一系列的 飞机一般的感受那么编译就成为了另一件大事了，NMP的环境编译一套下来整个人都懵了，那些乱七八糟的参数，我只想要一个开发环境，咋就那么难呢？为了偷懒，特地 google 了一下，原来Darwin系统还是有包管理的，类似linux 的yum or apt 题外话，如果你是windows的开发者，那么你有chocoWindows包管理 下载地址Win10的话也同样可以使用上面的办法安装一整套环境，或者你也可以使用WSL，毕竟Linux才是王道 1234567891011121314151617// 在开始之前挂上代理export all_proxy=socks5://127.0.0.1:1080// 使用Ruby获取Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;// Homebrew 更新brew update// 安装nginx brew install nginx// 安装PHP brew search php 因为homebrew core 迁移问题 php 5.6 低版本迁移问题，包括php5.6即将要终止维护的问题，将PHP迁移至其他子项目中所以先搜索一下或者你强制想要安装某个版本，那怎么办访问 PHP各个版本安装 12345就可以找到各个版本的安装方式执行一下// 我这里安装PHP5.6 是因为有老版本项目还得继续维护，非常讨厌5.6了brew install php@5.6// 中意的7.2安装brew install php@7.2 12345// 安装mysqlbrew install mysql// 安装nodejsbrew install node// 安装yarn composer 等等，只要你想的到的... 利器命令行篇在经历过 代理， 安装包 的痛苦之后，那么命令行又称为了懒人无法面对的事情，等等，我上一行命令是什么来着忘记了我好想记得是 git log xxxxx什么来着算了history看看吧，要不就一直up键找，直到找到为止，这样实在是太痛苦了后来又在网上逛了一圈，终于找到一个神器 ZSH 安装Oh-my-Zsh 使用CURL方式安装1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 使用Wget方式安装1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 安装后你会发现就只是变了个箭头而已，但是环境已经切到了ZSH上 ZSH自动提示插件 克隆仓库到当前用户的 ~/.zsh/zsh-autosuggestions. 1git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions 编辑 .zshrc 并向其中添加下面这行: 1source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 打开一个新的终端]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
</search>
