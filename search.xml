<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[循环 Pull Code]]></title>
    <url>%2F2020%2F04%2F13%2Fshell-pull-code%2F</url>
    <content type="text"><![CDATA[循环拉取文件夹下的git仓库最近管理的服务有点多，来不及仓库全部拉取一遍，那么我找了一个脚本 保存为pull_code.sh 123456789101112#!/bin/shfor dir in $(ls -d */)do cd $dir echo &quot;into $dir&quot; if [ -d &quot;.git&quot; ]; then git pull elif [ -d &quot;.svn&quot; ]; then svn update fi cd ..done 添加到 .zshrc123456789101112upgrade-repositories() &#123; for dir in */; do cd $dir echo &quot;into $dir&quot; if [ -d &quot;.git&quot; ]; then git pull elif [ -d &quot;.svn&quot; ]; then svn update fi cd .. done&#125; 尝试运行12➜ ~ cd /Volumes/Data/Code/www➜ www upgrade-repositories]]></content>
      <tags>
        <tag>shell</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[part.4 Borker]]></title>
    <url>%2F2020%2F04%2F03%2Fgo-micro-part-4%2F</url>
    <content type="text"><![CDATA[123官方对其解释为：broker 用于异步消息 是Pub/Sub的一个接口服务接口（Service Interface） - 所有特性都被打包在简单且高级的接口中，方便开发微服务。 producer 生产者consumer 消费者/订阅者]]></content>
  </entry>
  <entry>
    <title><![CDATA[part.3 Proxy Sidecar 代理服务]]></title>
    <url>%2F2020%2F04%2F01%2Fgo-micro-part-3%2F</url>
    <content type="text"><![CDATA[1TODO 目前proxy http 有问题，请勿使用 (注意所有代码均来自 https://github.com/micro/examples/) 概览Micro proxy提供基于go-micro框架的代理服务。它把go-micro中的各种特性组成一个本地化的服务, 并且支持把需要的特性转到其上, 比如服务发现、负载均衡、容错、插件化、包装器等等。我们并不需要给把每个go-micro服务都升级以满足底层框架所要求的种种东西, 只需要通过代理即可, 而其它语言就只用实现很轻的客户端而不用实现所有特性就能调用服务。 1micro proxy 其实就是服务与服务之间如果不方便直接调用时, 就可能通过proxy服务来调用另一方的接口。 示意图如下： 运行Micro代理默认是运行在8081端口下。 启动代理：12345678910111213141516micro proxyNAME: micro proxy - Run the service proxyUSAGE: micro proxy [command options] [arguments...]OPTIONS: --router value 将路由器设置为使用默认值, 例如 go.micro.router [$MICRO_ROUTER] --router_address value 设置路由器地址 [$MICRO_ROUTER_ADDRESS] --address value 设置代理HTTP地址, 例如 0.0.0.0:8081 [$MICRO_PROXY_ADDRESS] --protocol value 设置用于代理的协议, 例如mucp, grpc, http [$MICRO_PROXY_PROTOCOL] --endpoint value 将端点设置为路由到例如greeter或localhost:9090[$MICRO_PROXY_ENDPOINT] --auth value 设置代理身份验证, 例如jwt [$MICRO_PROXY_AUTH] --help, -h show help (default: false) 环境变量12345678910111213// 使用ACME安全协议MICRO_ENABLE_ACME=true// 配置白名单MICRO_ACME_HOSTS=example.com,api.example.com// 配置代理地址 // 代理服务MICRO_PROXY=go.micro.proxyMICRO_ROUTER = go.micro.routerMICRO_PROXY_ADDRESS=127.0.0.1:8081MICRO_PROXY_PROTOCOL= ucp, grpc, httpMICRO_PROXY_AUTH = jwtMICRO_PROXY_ENDPOINT = localhost:9090 or serivce name 实际应用范例假设现在你有个Server 因为某种原因无法进行直接访问, 服务如下 http server http client Proxy http 代码Proxy http 代码重点在 registryURI , proxyURI 这两个地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package proxyimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;github.com/micro/go-micro/registry&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;net/url&quot;)var ( registryURI = &quot;http://localhost:8081/registry&quot; proxyURI = &quot;http://localhost:8081&quot;)// 注册服务func Register(s *registry.Service) &#123; marshal, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) &#125; http.Post(registryURI, &quot;application/json&quot;, bytes.NewReader(marshal))&#125;// 注销func Deregister(s *registry.Service) &#123; b, _ := json.Marshal(s) req, _ := http.NewRequest(&quot;DELETE&quot;, registryURI, bytes.NewReader(b)) req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) http.DefaultClient.Do(req)&#125;// RPC调用func RpcCall(path string, req map[string]interface&#123;&#125;) (string, error) &#123; b, _ := json.Marshal(req) rsp, err := http.Post(proxyURI+path, &quot;application/json&quot;, bytes.NewReader(b)) if err != nil &#123; return &quot;&quot;, err &#125; defer rsp.Body.Close() b, err = ioutil.ReadAll(rsp.Body) if err != nil &#123; return &quot;&quot;, err &#125; return string(b), nil&#125;// http 调用func HttpCall(path string, req url.Values) (string, error) &#123; rsp, err := http.PostForm(proxyURI+path, req) if err != nil &#123; return &quot;&quot;, err &#125; b, err := ioutil.ReadAll(rsp.Body) if err != nil &#123; return &quot;&quot;, err &#125; return string(b), nil&#125;## Server 端的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;fmt&quot; &quot;srv/proxy&quot; &quot;net&quot; &quot;net/http&quot; &quot;os&quot; &quot;os/signal&quot; &quot;syscall&quot; &quot;github.com/micro/go-micro/registry&quot; &quot;github.com/pborman/uuid&quot;)// 定义服务var ( service = &amp;registry.Service&#123; // 注册服务名 Name: &quot;go.micro.srv.sayHello&quot;, // 注册节点 Nodes: []*registry.Node&#123; &#123; Id: &quot;go.micro.srv.sayHello-&quot; + uuid.NewUUID().String(), Address: &quot;localhost:4000&quot;, &#125;, &#125;, &#125;)func main() &#123; l, err := net.Listen(&quot;tcp&quot;, &quot;localhost:4000&quot;) if err != nil &#123; fmt.Println(err) &#125; // 提供给客户端调用的路径 http.HandleFunc(&quot;/sayHello&quot;, func(w http.ResponseWriter, r *http.Request) &#123; r.ParseForm() fmt.Fprintf(w, &quot;Hello %s!&quot;, r.Form.Get(&quot;name&quot;)) &#125;) go http.Serve(l, http.DefaultServeMux) // 注册服务 proxy.Register(service) notify := make(chan os.Signal, 1) signal.Notify(notify, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL) &lt;-notify proxy.Deregister(service) l.Close()&#125;### Client代码12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;srv/proxy&quot; &quot;net/url&quot;)func main() &#123; rsp, err := proxy.HttpCall(&quot;/sayHello&quot;, url.Values&#123;&quot;name&quot;: []string&#123;&quot;John&quot;&#125;&#125;) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(rsp)&#125; Proxy rpc 代码Proxy rpc 代码重点在 registryURI , proxyURI 这两个地址12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package proxyimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;github.com/micro/go-micro/registry&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;net/url&quot;)var ( registryURI = &quot;http://localhost:8081/registry&quot; proxyURI = &quot;http://localhost:8081&quot;)// 注册服务func Register(s *registry.Service) &#123; marshal, err := json.Marshal(s) if err != nil &#123; fmt.Println(err) &#125; http.Post(registryURI, &quot;application/json&quot;, bytes.NewReader(marshal))&#125;// 注销func Deregister(s *registry.Service) &#123; b, _ := json.Marshal(s) req, _ := http.NewRequest(&quot;DELETE&quot;, registryURI, bytes.NewReader(b)) req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) http.DefaultClient.Do(req)&#125;// RPC调用func RpcCall(path string, req map[string]interface&#123;&#125;) (string, error) &#123; b, _ := json.Marshal(req) rsp, err := http.Post(proxyURI+path, &quot;application/json&quot;, bytes.NewReader(b)) if err != nil &#123; return &quot;&quot;, err &#125; defer rsp.Body.Close() b, err = ioutil.ReadAll(rsp.Body) if err != nil &#123; return &quot;&quot;, err &#125; return string(b), nil&#125;// http 调用func HttpCall(path string, req url.Values) (string, error) &#123; rsp, err := http.PostForm(proxyURI+path, req) if err != nil &#123; return &quot;&quot;, err &#125; b, err := ioutil.ReadAll(rsp.Body) if err != nil &#123; return &quot;&quot;, err &#125; return string(b), nil&#125;## Server 端的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( &quot;fmt&quot; &quot;net&quot; &quot;net/http&quot; &quot;os&quot; &quot;os/signal&quot; &quot;syscall&quot; &quot;github.com/gorilla/rpc&quot; &quot;github.com/gorilla/rpc/json&quot; &quot;github.com/micro/go-micro/v2/registry&quot; &quot;github.com/pborman/uuid&quot;)var ( service = &amp;registry.Service&#123; Name: &quot;go.micro.srv.greeter&quot;, Nodes: []*registry.Node&#123; &#123; Id: &quot;go.micro.srv.greeter-&quot; + uuid.NewUUID().String(), Address: &quot;localhost&quot;, Port: 4000, &#125;, &#125;, &#125;)type Say struct&#123;&#125;type Request map[string]interface&#123;&#125;type Response stringfunc (s *Say) Hello(r *http.Request, req *Request, rsp *Response) error &#123; *rsp = Response(fmt.Sprintf(&quot;Hello %s!&quot;, (*req)[&quot;name&quot;])) return nil&#125;func main() &#123; l, err := net.Listen(&quot;tcp&quot;, &quot;localhost:4000&quot;) if err != nil &#123; fmt.Println(err) &#125; s := rpc.NewServer() s.RegisterCodec(json.NewCodec(), &quot;application/json&quot;) s.RegisterService(new(Say), &quot;&quot;) http.Handle(&quot;/&quot;, s) go http.Serve(l, http.DefaultServeMux) register(service) notify := make(chan os.Signal, 1) signal.Notify(notify, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL) &lt;-notify deregister(service) l.Close()&#125;### Client代码12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;srv/proxy&quot; &quot;net/url&quot;)func main() &#123; rsp, err := proxy.HttpCall(&quot;/sayHello&quot;, url.Values&#123;&quot;name&quot;: []string&#123;&quot;John&quot;&#125;&#125;) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(rsp)&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroService Part.2, go-micro Function 函数式编程模型]]></title>
    <url>%2F2020%2F04%2F01%2Fgo-micro-part-2%2F</url>
    <content type="text"><![CDATA[创建项目目录结构如下12345678910.├── go.mod├── go.sum├── main.go └── proto ├── user.pb.go ├── user.pb.micro.go └── user.proto1 directory, 6 files 定义protouser.proto12345678910111213141516// 定义语法为 proto3syntax = &quot;proto3&quot;;// 定义一个接口service User &#123; rpc SayHello (SayRequest) returns (SayResp) &#123; &#125;&#125;// 定义消息message SayRequest &#123; string yourName = 1;&#125;message SayResp &#123; string data = 1;&#125; 生成proto1protoc --proto_path=. --micro_out=$&#123;MODIFY&#125;:. --go_out=$&#123;MODIFY&#125;:. user.proto 创建服务1234567891011121314151617181920212223242526package mainimport ( &quot;context&quot; &quot;github.com/micro/go-micro/v2&quot; user &quot;go-shop/srv/functions/proto&quot;)type User struct &#123;&#125;// 实现 UserHandlerfunc (u *User) SayHello(ctx context.Context, req *user.SayRequest, resp *user.SayResp) error &#123; resp.Data = &quot;Hello ： &quot; + req.YourName return nil&#125;func main() &#123; function := micro.NewFunction( micro.Name(&quot;user&quot;), ) function.Init() function.Handle(new(User)) function.Run()&#125; 调用服务micro web 调用 micro call1234➜ function git:(master) ✗ micro call user User.SayHello &apos;&#123;&quot;yourName&quot;: &quot;fei&quot;&#125;&apos;&#123; &quot;data&quot;: &quot;Hello ： fei&quot;&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go Protocol Buffers Google的数据交换格式]]></title>
    <url>%2F2020%2F03%2F31%2Fgolang-golang-11%2F</url>
    <content type="text"><![CDATA[TL;DR 一个压缩快速通讯的一种规范协商协议12345参考链接地址https://developers.google.com/protocol-buffers/docs/proto3https://developers.google.com/protocol-buffers/ 什么是Protocol BuffersProtocol Buffers 是Google 开发的一种与语言无关，平台无关的可扩展机制，用于对结构化数据进行序列化（例如XML），但更小，更快，更简单。您定义要一次构造数据的方式，然后可以使用生成的特殊源代码轻松地使用各种语言在各种数据流中写入和读取结构化数据。 现在有许多框架等在使用Protocol Buffers。流行的RPC框架gRPC也是基于Protocol Buffers。 Protocol Buffers 目前有2和3两个版本号。 为什么要使用Protocol Buffers？Protocol Buffers 是一种 灵活，高效，自动化的解决方案。使用协议缓冲区，您可以编写.proto要存储的数据结构的描述。由此，协议缓冲区编译器创建了一个类，该类以有效的二进制格式实现协议缓冲区数据的自动编码和解析。生成的类为构成协议缓冲区的字段提供获取器和设置器，并以协议为单位来详细阅读和写入协议缓冲区。重要的是，协议缓冲区格式支持随时间扩展格式的想法，以使代码仍可以读取以旧格式编码的数据。 定义一个序列化的proto从官方示例的Person.proto文件开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 传递的消息// 语法 proto3 不定义时为 proto2syntax = &quot;proto3&quot;;// 定义包名，生成时会引用该命名空间 // 如下这个包名会在go-micro中生成 package go_micro_service_user// 在Go中，除非您在.proto文件中明确提供了go_package选项，否则该包将用作Go包名称。option gopackage=&quot;&quot;packge &quot;go.micro.service.user&quot;// 引入一个timestamp.proto // 来源 https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/timestamp.protoimport &quot;google/protobuf/timestamp.proto&quot;;// 定义一个用户服务service User &#123; // 定义接口 rpc Get (Request) returns (Response) &#123; &#125;&#125;message Person &#123; // 定义一个属性传递，并给属性加上顺序 // 属性加上顺序的含义是 标记标识该字段在二进制编码中使用的唯一 标记 string name = 1; // 姓名 int32 id = 2; // 唯一的用户ID string email = 3; // 邮箱 // 定义枚举 enum PhoneType &#123; MOBILE = 0; // 手机 HOME = 1; // 家庭座机 WORK = 2; // 工作手机 &#125; // 包含关联电话联系方式 message PhoneNumber &#123; string number = 1; //电话号码 PhoneType type = 2; // 关联枚举 &#125; // 多个电话号码 slice // 如果一个字段为repeated，则该字段可以重复任意次（包括零次）。重复值的顺序将保留在协议缓冲区中。将重复字段视为动态大小的数组。 repeated PhoneNumber phones = 4; //使用引用包中的 Timestamp结构 google.protobuf.Timestamp last_updated = 5;&#125;// 定义电话簿message AddressBook&#123; // 多个人的slice repeated Person people = 1;&#125; JSON对应表 支持的属性 类型 JSON example 备注 message object {&quot;fooBar&quot;: v, &quot;g&quot;: null, …} 生成JSON对象。 消息字段名称被映射到lowerCamelCase并成为JSON对象键。 如果指定了 json_name 段选项，则将使用指定的值作为键。 解析器同时接受lowerCamelCase名称（或由 json_name选项指定的名称）和原始原型字段名称。 null 是所有字段类型的可接受值，并被视为相应字段类型的默认值。 enum string &quot;FOO_BAR&quot; 使用proto中指定的枚举值的名称。 解析器接受枚举名称和整数值。 map object {&quot;k&quot;: v, …} 所有键都转换为字符串。 repeated V array [v, …] null 接受为空列表[]. bool true, false true, false string string &quot;Hello World!&quot; bytes base64 string &quot;YWJjMTIzIT8kKiYoKSctPUB+&quot; JSON值将是使用带有填充的标准base64编码编码为字符串的数据。 接受带/不带填充的标准或URL安全base64编码。 int32, fixed32, uint32 number 1, -10, 0 JSON值为十进制数字。 可以接受数字或字符串。 int64, fixed64, uint64 string &quot;1&quot;, &quot;-10&quot; JSON值将是一个十进制字符串。 可以接受数字或字符串。 float, double number 1.1, -10.0, 0, &quot;NaN&quot;, &quot;Infinity&quot; JSON值将是数字或特殊字符串值“ NaN”，“ Infinity”和“ -Infinity”之一。 可以接受数字或字符串。 指数表示法也被接受。 Any object {&quot;@type&quot;: &quot;url&quot;, &quot;f&quot;: v, … } 如果Any包含具有特殊JSON映射的值，则将其转换如下：{“ @type”：xxx，“ value”：yyy}。 否则，该值将转换为JSON对象，并且将插入“ @type”字段以指示实际的数据类型。 Timestamp string &quot;1972-01-01T10:00:20.021Z&quot; 使用RFC 3339，其中生成的输出将始终进行Z归一化，并使用0、3、6或9个小数位。 也可以接受“ Z”以外的偏移。 Duration string &quot;1.000340012s&quot;, &quot;1s&quot; 生成的输出始终包含0、3、6或9个小数位数，具体取决于所需的精度，后跟后缀“ s”。 可接受的任何小数位数（也无），只要它们适合纳秒精度，并且后缀“ s”是必需的。 Struct object { … } 任何JSON对象。 参见struct.proto。 Wrapper types various types 2, &quot;2&quot;, &quot;foo&quot;, true, &quot;true&quot;, null, 0, … 包装器在JSON中使用与包装后的原始类型相同的表示形式，不同之处在于在数据转换和传输期间允许并保留`null’。 FieldMask string &quot;f.fooBar,h&quot; 参见field_mask.proto. ListValue array [foo, bar, …] Value value 任何JSON值 NullValue null JSON null Empty object {} 空的JSON对象]]></content>
      <categories>
        <category>Go</category>
        <category>protobuf</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroService Part.1.1, 开启micro之路]]></title>
    <url>%2F2020%2F03%2F28%2Fgo-micro-part-1-1%2F</url>
    <content type="text"><![CDATA[获取Go microgo get -u github.com/micro/micro 安装配置环境本文使用版本为micro v2关于V1 to V2版本升级，请参考 https://mp.weixin.qq.com/s/XWf_my36Z7k3lfOySja3Sg 关于代理问题1234567// proxychains4 socks5 代理proxychains4 go mod downloadproxychains4 go mod tidyproxychains4 go get -u// goproxy.iogo env -w GOPROXY=&quot;https://goproxy.io,direct&quot; 服务注册中心 etcd || conuslwindows 用户请参考 Windows包管理 下载地址consul 安装1234# installbrew install consul# runconsul agent -dev ETCD 安装1234# installbrew install etcd# runetcd ETCD 参考链接 https://doczhcn.gitbook.io/etcd/index Consul 参考链接 https://kingfree.gitbook.io/consul/getting-startedmicro 命令列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116NAME: micro - A microservice runtimeUSAGE: micro [global options] command [command options] [arguments...]VERSION: latestCOMMANDS: api 运行api网关 bot 运行chatops机器人 cli 运行交互式CLI call 呼叫服务，使用样例: micro call greeter Say.Hello &apos;&#123;&quot;name&quot;: &quot;John&quot;&#125; services 列出网络中的服务 stream 创建服务流 publish 将消息发布到Topic stats 服务的统计信息 list 显示列表 register 注册项目 deregister 注销项目 get Get item from registry broker Run the message broker health 健康检查 proxy Run the service proxy monitor Run the monitoring service router Run the micro network router tunnel Run the micro network tunnel network Run the micro network node registry Run the service registry runtime 微服务运行时管理系统 run 运行服务 kill 强制退出正在运行的服务 ps 查看正在运行的服务 server Run the micro network server service 运行微服务 store Run the micro store service token API令牌 new 创建服务模板 plugin 插件命令 web 运行Web仪表板 debug 运行调试服务 logs 获取服务的日志 init micro 初始化 help, h 帮助命令GLOBAL OPTIONS: --client value Client for go-micro; rpc [$MICRO_CLIENT] --client_request_timeout value Sets the client request timeout. e.g 500ms, 5s, 1m. Default: 5s [$MICRO_CLIENT_REQUEST_TIMEOUT] --client_retries value Sets the client retries. Default: 1 (default: 1) [$MICRO_CLIENT_RETRIES] --client_pool_size value Sets the client connection pool size. Default: 1 (default: 0) [$MICRO_CLIENT_POOL_SIZE] --client_pool_ttl value Sets the client connection pool ttl. e.g 500ms, 5s, 1m. Default: 1m [$MICRO_CLIENT_POOL_TTL] --register_ttl value Register TTL in seconds (default: 60) [$MICRO_REGISTER_TTL] --register_interval value Register interval in seconds (default: 30) [$MICRO_REGISTER_INTERVAL] --server value Server for go-micro; rpc [$MICRO_SERVER] --server_name value Name of the server. go.micro.srv.example [$MICRO_SERVER_NAME] --server_version value Version of the server. 1.1.0 [$MICRO_SERVER_VERSION] --server_id value Id of the server. Auto-generated if not specified [$MICRO_SERVER_ID] --server_address value Bind address for the server. 127.0.0.1:8080 [$MICRO_SERVER_ADDRESS] --server_advertise value Used instead of the server_address when registering with discovery. 127.0.0.1:8080 [$MICRO_SERVER_ADVERTISE] --server_metadata value A list of key-value pairs defining metadata. version=1.0.0 [$MICRO_SERVER_METADATA] --broker value Broker for pub/sub. http, nats, rabbitmq [$MICRO_BROKER] --broker_address value Comma-separated list of broker addresses [$MICRO_BROKER_ADDRESS] --profile value Debug profiler for cpu and memory stats [$MICRO_DEBUG_PROFILE] --registry value Registry for discovery. etcd, mdns [$MICRO_REGISTRY] --registry_address value Comma-separated list of registry addresses [$MICRO_REGISTRY_ADDRESS] --runtime value Runtime for building and running services e.g local, kubernetes (default: &quot;local&quot;) [$MICRO_RUNTIME] --runtime_source value Runtime source for building and running services e.g github.com/micro/service (default: &quot;github.com/micro/services&quot;) [$MICRO_RUNTIME_SOURCE] --selector value Selector used to pick nodes for querying [$MICRO_SELECTOR] --store value Store used for key-value storage [$MICRO_STORE] --store_address value Comma-separated list of store addresses [$MICRO_STORE_ADDRESS] --store_namespace value Namespace for store data [$MICRO_STORE_NAMESPACE] --transport value Transport mechanism used; http [$MICRO_TRANSPORT] --transport_address value Comma-separated list of transport addresses [$MICRO_TRANSPORT_ADDRESS] --tracer value Tracer for distributed tracing, e.g. memory, jaeger [$MICRO_TRACER] --tracer_address value Comma-separated list of tracer addresses [$MICRO_TRACER_ADDRESS] --auth value Auth for role based access control, e.g. service [$MICRO_AUTH] --auth_token value Auth token used for client authentication [$MICRO_AUTH_TOKEN] --auth_public_key value Public key for JWT auth (base64 encoded PEM) [$MICRO_AUTH_PUBLIC_KEY] --auth_private_key value Private key for JWT auth (base64 encoded PEM) [$MICRO_AUTH_PRIVATE_KEY] --auth_exclude value Comma-separated list of endpoints excluded from authentication, e.g. Users.ListUsers [$MICRO_AUTH_EXCLUDE] --auth_provider value Auth provider used to login user [$MICRO_AUTH_PROVIDER] --auth_provider_client_id value The client id to be used for oauth [$MICRO_AUTH_PROVIDER_CLIENT_ID] --auth_provider_client_secret value The client secret to be used for oauth [$MICRO_AUTH_PROVIDER_CLIENT_SECRET] --auth_provider_endpoint value The enpoint to be used for oauth [$MICRO_AUTH_PROVIDER_ENDPOINT] --auth_provider_redirect value The redirect to be used for oauth [$MICRO_AUTH_PROVIDER_REDIRECT] --auth_provider_scope value The scope to be used for oauth [$MICRO_AUTH_PROVIDER_SCOPE] --config value The source of the config to be used to get configuration [$MICRO_CONFIG] --local Enable local only development: Defaults to true. (default: false) --peer Peer with the global network to share services (default: false) --enable_acme Enables ACME support via Let&apos;s Encrypt. ACME hosts should also be specified. (default: false) [$MICRO_ENABLE_ACME] --acme_hosts value Comma separated list of hostnames to manage ACME certs for [$MICRO_ACME_HOSTS] --acme_provider value The provider that will be used to communicate with Let&apos;s Encrypt. Valid options: autocert, certmagic [$MICRO_ACME_PROVIDER] --enable_tls Enable TLS support. Expects cert and key file to be specified (default: false) [$MICRO_ENABLE_TLS] --tls_cert_file value Path to the TLS Certificate file [$MICRO_TLS_CERT_FILE] --tls_key_file value Path to the TLS Key file [$MICRO_TLS_KEY_FILE] --tls_client_ca_file value Path to the TLS CA file to verify clients against [$MICRO_TLS_CLIENT_CA_FILE] --api_address value Set the api address e.g 0.0.0.0:8080 [$MICRO_API_ADDRESS] --proxy_address value Proxy requests via the HTTP address specified [$MICRO_PROXY_ADDRESS] --web_address value Set the web UI address e.g 0.0.0.0:8082 [$MICRO_WEB_ADDRESS] --network value Set the micro network name: local, go.micro [$MICRO_NETWORK] --network_address value Set the micro network address e.g. :9093 [$MICRO_NETWORK_ADDRESS] --router_address value Set the micro router address e.g. :8084 [$MICRO_ROUTER_ADDRESS] --gateway_address value Set the micro default gateway address e.g. :9094 [$MICRO_GATEWAY_ADDRESS] --tunnel_address value Set the micro tunnel address e.g. :8083 [$MICRO_TUNNEL_ADDRESS] --api_handler value Specify the request handler to be used for mapping HTTP requests to services; &#123;api, proxy, rpc&#125; [$MICRO_API_HANDLER] --api_namespace value Set the namespace used by the API e.g. com.example.api [$MICRO_API_NAMESPACE] --web_namespace value Set the namespace used by the Web proxy e.g. com.example.web [$MICRO_WEB_NAMESPACE] --web_url value Set the host used for the web dashboard e.g web.example.com [$MICRO_WEB_HOST] --enable_stats Enable stats (default: false) [$MICRO_ENABLE_STATS] --auto_update Enable automatic updates (default: false) [$MICRO_AUTO_UPDATE] --report_usage Report usage statistics (default: true) [$MICRO_REPORT_USAGE] --namespace value Set the micro service namespace (default: &quot;go.micro&quot;) [$MICRO_NAMESPACE] --plugin value Comma separated list of plugins e.g broker/rabbitmq, registry/etcd, micro/basic_auth, /path/to/plugin.so [$MICRO_PLUGIN] --help, -h show help (default: false) --version print the version (default: false) 实战利用micro new 创建微服务12345678910111213NAME: micro new - Create a service templateUSAGE: micro new [command options] [arguments...]OPTIONS: --namespace value 命名空间 com.example (默认: &quot;go.micro&quot;) --type value 服务类型 可选值为: api, fnc, srv, web (默认: &quot;srv&quot;) --fqdn value 完全限定域名 e.g com.example.srv.service (defaults to namespace.type.alias) --alias value 如果指定别名，别名是用作组合名称的一部分的简称 --plugin value 指定插件 e.g --plugin=registry=etcd:broker=nats or use flag multiple times --gopath 在gopath中创建服务。 默认为true。 运行生产指令1micro new go-shop/user-srv --namespace go.shop --type srv 123456789101112131415161718192021222324252627282930313233➜ src micro new go-shop/user-srv --namespace go.shop --type srvCreating service go.shop.srv.user in /Volumes/Data/gopath/src/go-shop/user-srv目录结构.├── main.go 主入口文件├── generate.go make proto合集 请自己定义├── plugin.go 插件指定├── handler 处理程序│ └── user.go├── subscriber 订阅│ └── user.go├── proto/user proto文件│ └── user.proto├── Dockerfile docker环境├── Makefile make 指令 提供了proto 生成以及 build test docker等命令├── README.md└── go.mod出现下文继续操作 download protobuf for micro:安装 protobufbrew install protobuf// 安装 proto,protoc-gen-gogo get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;// 安装 protoc-gen-microgo get -u github.com/micro/protoc-gen-micro/v2compile the proto file user.proto:// 生成 protobufcd go-shop/user-srvprotoc --proto_path=.:$GOPATH/src --go_out=. --micro_out=. proto/user/user.proto 此时user-srv 服务已经创建，输出的信息如上, 请按照提示和注释进行生产proto 打开项目 1goland . 下载依赖 1go mod tidy 尝试运行123456➜ user-srv go run main.go2020-03-29 15:27:32 level=info Starting [service] go.micro.service.user2020-03-29 15:27:32 level=info Server [grpc] Listening on [::]:516822020-03-29 15:27:32 level=info Broker [eats] Connected to [::]:516842020-03-29 15:27:32 level=info Registry [mdns] Registering node: go.micro.service.user-478c8fe4-82fb-4c33-ae0e-9fe6290adbda2020-03-29 15:27:32 level=info Subscribing to topic: go.micro.service.user 可以看到 服务运行起来了，输出信息分别为 第1行 服务名称 go.micro.service.user 第2行 运行服务类型 grpc 监听端口 51682 第3行 运行 Broker 类型 eats 连接到 51684 (broker 用于异步消息)可降维理解为 事件代理例如，你想 N 个不同的服务针对使用 gRPC 创建新用户采取行动，可能需要在用户服务中实例化 N 个客户端。而借助事件发布订阅或事件驱动架构，你的服务就不需要关心这些。参考连接： https://micro.mu/docs/cn/go-micro-internals.html#%E4%BB%A3%E7%90%86broker 第4行 注册到 mdns , 注册节点 go.micro.service 第5行 订阅 Topic go.micro.service.user 服务运行起来后，因为其是一个grpc服务，我们可以使用如下的调用方式 调用RPC 服务 micro call1234➜ user-srv micro call go.micro.service.user User.Call &apos;&#123;&quot;name&quot;: &quot;c&quot;&#125;&apos;&#123; &quot;msg&quot;: &quot;Hello fei&quot;&#125; 查看 micro 控制面板如果你没有办法了解其暴露的接口，可以使用此方法查看其可调用的方法12345➜ user-srv micro web2020-03-29 15:47:36 level=info service=web HTTP API Listening on [::]:80822020-03-29 15:47:36 level=info service=web Starting [service] go.micro.web2020-03-29 15:47:36 level=info service=web Server [grpc] Listening on [::]:521212020-03-29 15:47:36 level=info service=web Registry [mdns] Registering node: go.micro.web-4327b842-196c-4187-b109-a2235fbfc9da 打开 http://localhost:8082 即可查看服务 micro 网关12345678910111213141516171819➜ user-srv micro api --helpNAME: micro api - 启用API网关USAGE: micro api [command options] [arguments...]OPTIONS: --address value 设置API网关监听地址 e.g 0.0.0.0:8080 [$MICRO_API_ADDRESS] --handler value 指定用于将HTTP请求映射到服务的请求处理程序 ; &#123;api, event, http, rpc&#125; [$MICRO_API_HANDLER] --namespace value 设置API使用的名称空间 e.g. com.example.api [$MICRO_API_NAMESPACE] --resolver value 设置API使用的主机名解析器 &#123;host, path, grpc&#125; [$MICRO_API_RESOLVER] --enable_rpc 启用直接通过/ rpc调用后端 (default: false) [$MICRO_API_ENABLE_RPC] --enable_cors 启用CORS，从而允许前端应用程序调用该API (default: true) [$MICRO_API_ENABLE_CORS] --help, -h show help (default: false)请注意，该调用方式有一个前提，提供API网关相关代码 Or 指定命名空间 运行API 指定命名空间的方式micro api --namespace=go.micro.service 123456➜ user-srv micro api --namespace=go.micro.service2020-03-29 16:10:53 level=info service=api Registering API Default Handler at /2020-03-29 16:10:53 level=info service=api HTTP API Listening on [::]:80802020-03-29 16:10:53 level=info service=api Starting [service] go.micro.api2020-03-29 16:10:53 level=info service=api Server [grpc] Listening on [::]:524042020-03-29 16:10:53 level=info service=api Registry [mdns] Registering node: go.micro.api-69c94b39-0fa8-474c-9edd-c5e1db9157b0 打开 http://localhost:8080/user/user/call?name=fei 即可查看响应 123&#123; &quot;msg&quot;: &quot;Hello fei&quot;&#125; 建立一个API的方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( &quot;encoding/json&quot; &quot;log&quot; &quot;strings&quot; api &quot;github.com/micro/go-micro/api/proto&quot; &quot;github.com/micro/go-micro/v2&quot; &quot;github.com/micro/go-micro/v2/errors&quot; user &quot;go-shop/user-srv/proto/user&quot; &quot;context&quot;)type User struct &#123; Client user.UserService&#125;// 实现 UserHandler 的Callfunc (s *User) Call(ctx context.Context, req *api.Request, rsp *api.Response) error &#123; log.Print(&quot;开始接受请求&quot;) name, ok := req.Get[&quot;name&quot;] log.Print(name) if !ok || len(name.Values) == 0 &#123; return errors.BadRequest(&quot;go.micro.api.user&quot;, &quot;名称不能为空&quot;) &#125; // 调用RPC服务 response, err := s.Client.Call(ctx, &amp;user.Request&#123; Name: strings.Join(name.Values, &quot; &quot;), &#125;) if err != nil &#123; return err &#125; // 准备返回数据 rsp.StatusCode = 200 b, _ := json.Marshal(map[string]string&#123; &quot;message&quot;: response.Msg, &#125;) rsp.Body = string(b) return nil&#125;func main() &#123; service := micro.NewService( micro.Name(&quot;go.micro.api.user&quot;), ) log.Println(&quot;开始API服务&quot;) // parse command line flags service.Init() // 初始化服务调用 service.Server().Handle( service.Server().NewHandler( &amp;User&#123;Client: user.NewUserService(&quot;go.micro.service.user&quot;, service.Client())&#125;, ), ) if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 上述代码保存到 api/api.go 中 运行API123456789101112➜ user-srv micro api --handler=api2020-03-29 17:11:09 level=info service=api Registering API Request Handler at /2020-03-29 17:11:09 level=info service=api HTTP API Listening on [::]:80802020-03-29 17:11:09 level=info service=api Starting [service] go.micro.api2020-03-29 17:11:09 level=info service=api Server [grpc] Listening on [::]:533702020-03-29 17:11:09 level=info service=api Registry [mdns] Registering node: go.micro.api-719da628-e5a1-4fe8-9dcf-da03c63dfe22➜ user-srv go run api/api.go2020-03-29 17:14:26.735917 I | 开始API服务2020-03-29 17:14:26 level=info Starting [service] go.micro.api.user2020-03-29 17:14:26 level=info Server [grpc] Listening on [::]:534412020-03-29 17:14:26 level=info Registry [mdns] Registering node: go.micro.api.user-7eed385f-6471-4317-988a-d8fa380ff81a 访问 http://localhost:8080/user/user/call?name=fei 时 返回12345678&#123; &quot;message&quot;: &quot;Hello fei&quot;&#125;同时日志会打印 2020-03-29 17:17:19.429649 I | 开始接受请求2020-03-29 17:17:19.429712 I | key:&quot;name&quot; values:&quot;fei&quot; 总结so,本次为你介绍了 micro new 使用官方new 指令初始化项目模板 micro web 使用控制台查看服务，调用等 micro api 网关的使用等 参考资料https://micro.mu/docs/cn/api.htmlhttps://micro.mu/docs/cn/web.html]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编指令整理]]></title>
    <url>%2F2020%2F01%2F15%2Fasm-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[TL;DR 汇编寄存器整理1. 通用数据传送指令12345678910111213141516MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点, AL为表的索引值(0-255,即0-FFH); 返回AL为查表结果.([BX+AL]-&gt;AL) 2. 输入输出端口传送指令:1234IN I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; ) OUT I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 ) 输入输出端口由立即方式指定时,其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 3. 目的地址传送指令:123456LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令:123456LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈. 算术运算指令1234567891011121314151617181920212223242526272829ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. 逻辑运算指令1234567891011121314151617AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL 串指令1234567891011MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中. ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. 无条件转移指令 (长转移)123JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )1234567891011121314151617181920JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移. 循环控制指令(短转移)12345LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 中断指令123INT 中断指令 INTO 溢出中断 IRET 中断返回 处理器控制指令123456789101112HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. 伪指令1234567DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束. 处理机控制指令：标志处理指令123456789101112CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 浮点运算指令集控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)1234567891011121314151617181920212223FINIT 初始化浮点部件 9B DB E3 FCLEX 清除异常 9B DB E2 FDISI 浮点检查禁止中断 9B DB E1 FENI 浮点检查禁止中断二 9B DB E0 WAIT 同步CPU和FPU 9B FWAIT 同步CPU和FPU D9 D0 FNOP 无操作 DA E9 FXCH 交换ST(0)和ST(1) D9 C9 FXCH ST(i) 交换ST(0)和ST(i) D9 C1iii FSTSW ax 状态字到ax 9B DF E0 FSTSW word ptr mem 状态字到mem 9B DD mm111mmm FLDCW word ptr mem mem到状态字 D9 mm101mmm FSTCW word ptr mem 控制字到mem 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 D9 mm100mmm FSTENV word ptr mem 全环境到mem 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 DD mm100mmm FSAVE word ptr mem FPU状态到mem 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 D9 F7 FSETPM 浮点设置保护 DB E4 数据传送指令123456789101112131415161718192021222324252627282930313233343536373839404142FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii 比较指令12345678910111213141516FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 运算指令1234567891011121314151617181920212223242526272829303132333435363738394041424344FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器， 而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何， 经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器， 来源操作数必须是字组整数或短整数形态的变数 FSUB 减 FSUBP FSUBR 减数与被减数互换 FSUBRP FISUB FISUBR FMUL 乘 FMULP FIMUL FDIV 除 FDIVP FDIVR FDIVRP FIDIV FIDIVR FCHS 改变 ST 的正负值 FABS 把 ST 之值取出，取其绝对值后再存回去。 FSQRT 将 ST 之值取出，开根号后再存回去。 FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入ST里，而 ST(1)之值不变 ST(1)必须是在 -32768 到 32768(-215到215)之间的整数， 如果超过这个范围计算结果无法确定，如果不是整数ST(1)会先向零舍入成整数 再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。 FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU提供四种舍入方式， 由 FPU 的控制字组(control word)中的RC两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroService Part.1, 认识Go-Micro]]></title>
    <url>%2F2019%2F07%2F11%2Fgo-micro-part-1%2F</url>
    <content type="text"><![CDATA[TL;DR1234参考地址https://micro.mu/docs/cn/index.html目前伦敦在修改商业版本，开源社区由https://github.com/vtolstov 维护 Part.1micro由以下几个部分组成： API网关（API Gateway）： - API Gateway 网关。API网关是请求的入口，把请求动态路由到具体服务。网关允许我们建立可伸缩的后台微服务架构，并且让工作在前端的公共API更健壮。Micro API基于服务发现拥有强大的路由能力，通过我们预置的handlers插件，它可以处理http、gRPC、websocket、消息推送事件等等。 命令行接口（Interactive CLI）： 交互式的命令行接口。CLI通过终端可以描述、查询、直接与平台和服务进行交互。CLI提供所有的命令让开发者明白微服务正在处理的事情。CLI也包含了交互模式。 服务代理（Service Proxy）： 服务代理，基于Go Micro和MUCP协议构建的透明的代理服务。它将服务发现、负载均衡、消息编码、中间件、传输及代理插件转移到某一（具体服务所在）位置，同api不同，它不暴露任何接口，只工作在内部环境，相当于桥接内部服务。 模板生成（Template Generation）： 基于模板快速创建新的服务代码。Micor提供预置的模板，通过模板编写统一风格的代码。 SlackOps小机器人（SlackOps Bot）： Slack小机器人插件，当它运行中服务中时，这个插件允许开发者通过Slack消息来操作平台。MicroBot插件提供聊天配置选项，这样就可以让团队通过向小机器人发送聊天消息来做一些我们希望它做的事，这里面当然也包含像动态发现服务一样创建slack命令。 管理控制台（Web Dashboard）： 通过Web管理控制台，可以直接在Web页面上查看服务的运行情况，展示端点信息，请求与响应状态，甚至直接向服务进行查询。管理控制台也有CLI交互页面提供给开发者在线上处理，就像直接操作终端一样。 Go-micro框架（Go Framework）： Go Micro框架是Micro的底层、核心。GO-Micro把分布式服务抽象，并提供简便的方式让大家构建具有高弹性的微服务。 Part.2整体框架组成 micro 1234567Go Micro可以帮你编写微服务。Go Micro抽象出分布式系统集成服务发布、RPC、分发/订阅机制、消息编码超时容错、重试机制、负载均衡功能可扩展可插拔的后台交换技术 config 1234567Go Config可以管理复杂的配置动态管理 - 加载配置不需要重启可插拔 - 可以选择从哪个源加载配置：文件、环境变量、consul。可合并 - 针对多个配置源可以合并并重写。回退 - 可以指定当key不存在时设置值。可观察 - 可以查看配置的变动。 plugins 12345Go Pluginsgo-micro与micro的插件集包含了绝大多数的后端技术grpc, kubernetes, etcd, kafka等等经过生产环境验证 特性Go Micro把分布式系统的各种细节抽象出来。下面是它的主要特性。 服务发现（Service Discovery） - 自动服务注册与名称解析。服务发现是微服务开发中的核心。当服务A要与服务B协作时，它得知道B在哪里。默认的服务发现系统是Consul，而multicast DNS (mdns，组播)机制作为本地解决方案，或者零依赖的P2P网络中的SWIM协议（gossip）。 Registry 负载均衡（Load Balancing） - 在服务发现之上构建了负载均衡机制。当我们得到一个服务的任意多个的实例节点时，我们要一个机制去决定要路由到哪一个节点。我们使用随机处理过的哈希负载均衡机制来保证对服务请求颁发的均匀分布，并且在发生问题时进行重试。 Selector 消息编码（Message Encoding） - 支持基于内容类型（content-type）动态编码消息。客户端和服务端会一起使用content-type的格式来对Go进行无缝编/解码。各种各样的消息被编码会发送到不同的客户端，客户端服服务端默认会处理这些消息。content-type默认包含proto-rpc和json-rpc。 Codec Request/Response - RPC通信基于支持双向流的请求/响应方式，我们提供有抽象的同步通信机制。请求发送到服务时，会自动解析、负载均衡、拨号、转成字节流，默认的传输协议是http/1.1，而tls下使用http2协议。Transport 异步消息（Async Messaging） - 发布订阅（PubSub）头等功能内置在异步通信与事件驱动架构中。事件通知在微服务开发中处于核心位置。默认的消息传送使用点到点http/1.1，激活tls时则使用http2。 Broker 可插拔接口（Pluggable Interfaces） - Go Micro为每个分布式系统抽象出接口。因此，Go Micro的接口都是可插拔的，允许其在运行时不可知的情况下仍可支持。所以只要实现接口，可以在内部使用任何的技术。更多插件请参考：github.com/micro/go-plugins。 关于如何了解框架https://micro.mu/docs/cn/go-micro.html 参考https://micro.mu/docs/cn/features.html]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>go-micro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言汇编解释-1]]></title>
    <url>%2F2019%2F03%2F31%2Fclang-cinasm-1%2F</url>
    <content type="text"><![CDATA[TL;DR本文转载自 github冻死胖子-github1所用示例均为翻新，有 参考《Linux C编程一站式学习》以及冻死胖子的Github，如有版权问题，请联系站长删除 本教程使用的编译器为：12345➜ ~ clang -vApple LLVM version 10.0.1 (clang-1001.0.46.3)Target: x86_64-apple-darwin18.5.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin Show Me The Code老规矩，万物之本 打印 HelloWorld123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\n&quot;); return 0;&#125; 代码写好了，如何运行呢， 命令如下，生成.out可执行文件123456789101112➜ CinASM clang Hello.c ➜ CinASM ls -la total 40drwxr-xr-x 7 lookwi staff 238 Mar 31 18:40 .drwxr-xr-x@ 14 lookwi staff 476 Mar 31 18:32 ..drwxr-xr-x 7 lookwi staff 238 Mar 31 18:39 .idea-rw-r--r-- 1 lookwi staff 109 Mar 31 18:33 CMakeLists.txt-rwxr-xr-x 1 lookwi staff 8432 Mar 31 18:40 a.outdrwxr-xr-x 7 lookwi staff 238 Mar 31 18:33 cmake-build-debug-rw-r--r-- 1 lookwi staff 79 Mar 31 18:33 main.c➜ CinASM ./a.out Hello, World! 说好的ASM123456789101112131415161718192021222324252627282930313233➜ CinASM clang -S main.c➜ CinASM cat main.s .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 14 sdk_version 10, 14 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc # 指定入口函数## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp movl $0, -4(%rbp) leaq L_.str(%rip), %rdi movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot;.subsections_via_symbols 解释之前还是说一下汇编基础表关于寄存器CS（Code Segment）：代码段寄存器DS（Data Segment）：数据段寄存器SS（Stack Segment）：堆栈段寄存器ES（Extra Segment）：附加段寄存器当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS, ES esi，edi，分别是16位寄存器DI和SI的32位扩展。它们是源变址寄存器，和目的变址寄存器，用于串操作指令中。同时，它们也可以作为通用寄存器使用。 EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。EDX 则总是被用来放整数除法产生的余数。 常用寄存器有16个，分为x86通用寄存器以及r8-r15寄存器。 通用寄存器中，函数执行前后必须保持原始的寄存器有3个：是rbx、rbp、rsp。rx寄存器中，最后4个必须保持原值：r12、r13、r14、r15。保持原值的意义是为了让当前函数有可信任的寄存器，减小在函数调用过程中的保存&amp;恢复操作。除了rbp、rsp用于特定用途外，其余5个寄存器可随意使用。 通用寄存器中，不必假设保存值可随意使用的寄存器有5个：是rax、rcx、rdx、rdi、rsi。其中rax用于第一个返回寄存器（当 然也可以用于其它用途），rdx用于第二个返回寄存器（在调用函数时也用于第三个参数寄存器）。rcx用于第四个参数。rdi用于第一个参数。rsi用于 第二个函数参数。 r8、r9分配用于第5、第6个参数。 这里需要说明的是因为实验环境为Darwin内核，因此许多汇编代码是不同的大致可分为两种不同的类型 DOS/Windows (Intel 风格) Unix 和 Linux 系统 ( AT&amp;T 风格) table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 20% ; } table th:nth-of-type(3){ width: 20%; } table th:nth-of-type(4){ width: 40%; } AT&amp;T 格式 Intel 格式 解释 区别 pushl %eax push eax 在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀 pushl $1 push 1 在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。 addl $1, %eax add eax, 1 AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边 movb val, %al mov al, byte ptr val 在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的 ljump $section, $offset jmp far section:offset 在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上’*’作为前缀，而在 Intel 格式中则不需要 lcall $section, $offset call far section:offset 远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 “ljump” 和 “lcall”，而在 Intel 汇编格式中则为 “jmp far” 和 “call far” lret $stack_adjust ret far stack_adjust 与（jump/call）相应的远程返回指令 解释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374➜ CinASM clang -S main.c➜ CinASM cat main.s .section __TEXT,__text,regular,pure_instructions ## 编译器指令 告知编译器相关的信息或者进行特定操作 ## __TEXT,__text用来存放代码指令, 代码一般都放在这一节 ## regular：regular类型的节区可以包含任意代码或数据，并且链接器不会对它们进行任何特殊处理。 .build_version macos, 10, 14 sdk_version 10, 14 ## 编译信息 .globl _main ## -- Begin function main ## .global关键字用来让一个符号对链接器可见，可以供其他链接对象模块使用。 ## .global _main 让 _main 符号成为可见的标示符，这样链接器就知道跳转到程序中的什么地方并开始执行。 .p2align 4, 0x90 ## 将位置计数器（在当前子部分中）填充到特定存储边界_main: ## @main .cfi_startproc # Main 函数开始 # 用在每个函数的开始，用于初始化一些内部数据结构## %bb.0: pushq %rbp # 保存旧的帧指针，相当于创建新的栈帧 .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 ## CFI 指令 movq %rsp, %rbp ## 指令则将rsp寄存器的值赋值给rbp寄存器．这样一来，属于main函数的栈区域便构建好了． .cfi_def_cfa_register %rbp # CFI 指令 修改计算CFA的规则。从现在开始，将使用寄存器而不是旧寄存器。 偏移量保持不变 subq $16, %rsp # 也就是rsp = rsp - 16 将栈地址减去16, 用于存放局部变量 movl $0, -4(%rbp) # 将0存放于rbp - 4的值作为指针指向的内存地址, 也就是栈顶下方4 byte位置, 从后面的代码中推测出这里存放的是main方法的默认返回值0 leaq L_.str(%rip), %rdi # 指令引用了L_.str这个标签, 在经过汇编器汇编后会将标汇编为字符串所存放的地址, 让程序可以定位到字符串. 首先lea指令是mov指令的变种，据说，lea指令是x86体系结构中，是一条最古老但是从某个方面来讲又是最神奇的指令。 表面上看，它做的事情非常简单，根据括号里的源操作数来计算地址，然后把地址加载到目标寄存器中。 上面的操作就是 先计算地址 L_.str(%rip) 然后把最终地址载到寄存器 rdi 中 movb $0, %al # 把 0 值传送给32为的EAX寄存器值 callq _printf # 调用 printf 函数 将下一条指令的地址入栈，然后跳转到目标地址处执行 指令callq _printf将%rdi作为第一个参数(里面存放的是&quot;hello, world\n&quot;字符串的地址)调用_printf方法 ### 方法尾(epilogue), 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置 xorl %ecx, %ecx # 将ecx 计数器 置零咯 movl %eax, -8(%rbp) ## 4-byte Spill # movl是以寄存器运算结果为游标，访问内存获得该地址的值，然后给目标寄存器赋值 movl %ecx, %eax addq $16, %rsp popq %rbp # 从 RBP 寄存器栈中取出数据 retq ### 方法尾(epilogue), 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置 .cfi_endproc # Main 函数结束 #.cfi_startproc 和 .cfi_endproc 分别是 dwarf2 CFI 的初始过程和结束过程指 ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot; # 分配一段字符串内存单元，并用expr初始化字符串内存单元.subsections_via_symbols 解释完了，有什么不对的地方，欢迎留言给我，请多多指教]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>clang</tag>
        <tag>汇编</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang Part.1 包管理器]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-1%2F</url>
    <content type="text"><![CDATA[TL;DR Part.1, Golang Modulesgo modgo building package manager. go mod是go语言内置的包管理工具，集成在go tool中，安装好go就可以使用。 要求: go version &gt;= 1.11 官方文档： https://tip.golang.org/cmd/go… 环境变量12345678910# 通过环境变量GOPROXY设置代理export GOPROXY=https://goproxy.ioORproxychains4 go get github.com/shirou/gopsutil/disk# go mod功能开关，默认是auto，在gopath中不启用# 可设置为on强制启用export GO111MODULE=on 初始化 go mod initinit报错outside gopath no import comments 12345# 方法一 手动创建go.mod文件， 写入module xxxecho &apos;module xxx&apos; &gt; go.mod# 方法二 main包加入import声明package main // import &quot;xxx&quot; go mod download下载依赖 go mod tidy同步依赖包，添加需要的，移除多余的 go mod vendor将依赖包放入vendor go get 下载/升级依赖go mod不再下载源码进$GOPATH/src go mod的下载目录在$GOPATH/pkg/mod，并且是文件权限是只读的-r--r--r-- 12# tag必须以v开头 v1.2.3格式go get -u xxx.com/pkg@2.1.0 vendor 模式go mod是不推荐使用vendor目录的，而是直接使用source或cache中的包。 在根目录有vendor文件夹时默认使用vendor模式。此模式下依赖只从vendor中找。 https://github.com/golang/go/… 1234567# vendor模式下get报错：go get: disabled by -mod=vendor# mod有三个取值# mod can be &apos;&apos;, &apos;readonly&apos;, or &apos;vendor&apos;# 两种赋值方式都可以-mod=&apos;&apos;-mod &apos;&apos; replace让原本依赖的 github.com/repo/pkg 包，实际使用 github.com/your-fork/pkg@version。 1go mod edit -replace github.com/repo/pkg=github.com/your-fork/pkg@version 清缓存go clean -modcache go.mod &amp; go.sumgo.mod：依赖列表和版本约束。 go.sum：记录module文件hash值，用于安全校验。 最佳实践go mod不推荐使用vendor，不要将vendor提交到版本控制。 提交go.mod，可以忽略go.sum，因为会根据校验sum跨平台可能报错。]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. 反射，IO, net/http]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-10%2F</url>
    <content type="text"><![CDATA[反射反射介绍) 如果你对反射不了解，请看维基百科解释 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type User struct &#123; ID uint64 Username string&#125;func main() &#123; var str = &quot;我是一个字符串&quot; fmt.Println(&quot;反射出来的类型为: &quot;, reflect.TypeOf(str)) //反射出来的类型为: string var i32 int32 = 32 fmt.Println(&quot;反射出来的类型为: &quot;, reflect.TypeOf(i32)) //反射出来的类型为: int32 var slice = make([]string, 0) fmt.Println(&quot;反射出来的类型为: &quot;, reflect.TypeOf(slice)) //反射出来的类型为: int32 var user User user.ID = 1 user.Username = &quot;admin&quot; tp := reflect.TypeOf(user) fmt.Println(&quot;反射出类型： &quot;, tp) fmt.Println(&quot;反射struct 的 名称： &quot;, tp.Name()) fmt.Println(&quot;反射出值: &quot;, reflect.ValueOf(user)) fmt.Println(&quot;反射出来的Kind: &quot;, tp.Kind()) for i := 0; i &lt; tp.NumField(); i++ &#123; fmt.Println(&quot;字段 :&quot;, i, tp.Field(i), &quot;字段名称 :&quot;, tp.Field(i).Name, &quot;字段类型 :&quot;, tp.Field(i).Type) &#125;&#125; I/O1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;os&quot;)func main() &#123; // 读取文件 data, err := ioutil.ReadFile(&quot;./test.txt&quot;) if err != nil &#123; fmt.Println(&quot;无法读取文件,&quot;, err) &#125; fmt.Println(&quot;文件内容：&quot;, string(data)) // 创建文件 f, err := os.Create(&quot;./test1.txt&quot;) if err != nil &#123; fmt.Println(err) return &#125; l, err := f.WriteString(&quot;俺也一样&quot;) if err != nil &#123; fmt.Println(err) err := f.Close() fmt.Println(err) return &#125; fmt.Println(l, &quot;写入完成&quot;) err = f.Close() if err != nil &#123; fmt.Println(err) return &#125; // 追加文件 file, err := os.OpenFile(&quot;./test1.txt&quot;, os.O_APPEND|os.O_WRONLY, 0644) if err != nil &#123; fmt.Println(err) &#125; newLine := &quot;俺也一样 +1&quot; _, err = fmt.Fprintln(file, newLine) if err != nil &#123; fmt.Println(err) err := file.Close() fmt.Println(err) &#125; err = file.Close() if err != nil &#123; fmt.Println(err) &#125; fmt.Println(&quot;文件追加完成&quot;)&#125; net/http123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot;)func main() &#123; // 客户端 获取内容 resp, err := http.Get(&quot;https://www.fei.dev&quot;) if err != nil &#123; // handle error fmt.Println(err) return &#125; //程序在使用完回复后必须关闭回复的主体。 defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) fmt.Println(string(body)) // 服务端 http.HandleFunc(&quot;/&quot;, func(writer http.ResponseWriter, request *http.Request) &#123; writer.Write([]byte(&quot;你好朋友.&quot;)) &#125;) err = http.ListenAndServe(&quot;:8088&quot;, nil) if err != nil &#123; fmt.Println(err) &#125;&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 安装和配置]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-2%2F</url>
    <content type="text"><![CDATA[TL;DR 安装 Mac 安装brew install go 设置环境变量12345678export GOPATH=/Volumes/Data/gopathexport GOROOT=/usr/local/opt/go/libexec# 开启go mod 模式 下一章节会说到export GO111MODULE=onexport PATH=&quot;$PATH:$GOPATH/bin:$GOROOT/bin&quot;#此处为go get 代理，但是并没有什么卵用#export GOPROXY=https://goproxy.ioexport GOPROXY= 代理问题上面说到GOPROXY没有什么卵用，还是经常网络掉包什么的这里推荐几个方式proxifer 强制全局走代理 or 1proxychains4 go get -u github.com/swaggo/swag 参考链接Mac OSX 终端走 shadowsocks 代理 Proxifier+Shadowshocks系统全局代理的正确姿势]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 变量,类型,常量,函数，包]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-4%2F</url>
    <content type="text"><![CDATA[TL;DR 变量代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667TL;DR 如果初学者，请暂时忽略下列注释，避免无法理解// 构建约束 支持多行的构建约束，多行之间是AND关系如下所示 编译(linux AND 386) OR (darwin AND (NOT cgo))编译linux 和 386支持的代码 or 编译 达尔文内核 不进行CGO// +build linux,386 darwin,!cgo 构建linux 或者 达尔文 and 386// +build linux darwin// +build 386忽略编译，如果想在同一个package下多个main包，使用该方式，编译时指定// +build ignore单元测试 集成测试// +build integration// 运行测试方式 go test -tags=integration $(go list ./tests/... | grep -v /vendor/) -v/// main包package main// 导入 fmt包import &quot;fmt&quot;// 主函数func main() &#123; // int变量声明 默认值0填充 var money int // 用fmt包进行输出 fmt.Println(&quot;how much money you have left : &quot;, money) // 输出 how much money you have left : 0 // int变量声明 并赋值 var money2 int = 1000 // 用fmt包进行输出 fmt.Println(&quot;how much money you have left : &quot;, money2) // 输出 how much money you have left : 1000 /** *自动推断值类型 */ var money3 = 9999 // 简短自动推断类型 此用法最多 money4 := 8888 fmt.Println(&quot;money 3 is :&quot;, money3, &quot;money4 is :&quot;, money4) // 批量声明推断变量 var a1, a2, a3, a4 = 100, &quot;0xFFFF&quot;, false, 0xFFFFFFF fmt.Println(&quot;a1 is &quot;, a1, &quot;; a2 is&quot;, a2, &quot;; a3 is&quot;, a3, &quot;; a4 is&quot;, a4) //a1 数值int, a2 字符串, a3 bool , a4 16进制 //a1 is 100 ; a2 is 0xFFFF ; a3 is false ; a4 is 268435455 // 使用16进制时需注意 溢出问题 0xFFFFFFFF 连续32个1的内存 // var a = 0xFFFFFFFF // fmt.Println(a) // 上面的实例将输出 constant 4294967295 overflows int //批量声明固定类型的变量 var k1, k2 = 100, 88 fmt.Println(&quot;k1 is &quot;, k1, &quot;; k2 is&quot;, k2) // 涵盖声明 var ( version = &quot;1.1.1&quot; port = 9501 name = &quot;user-srv&quot; ) fmt.Printf(&quot;%v Server is starting in port %v. version : %v . &quot;, name, port, version) // user-srv Server is starting in port 9501. version : 1.1.1 . &#125; 类型 bool 数字类型 int8, int16, int32, int64, int uint8, uint16, uint32, uint64, uint float32, float64 complex64, complex128 byte rune string 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() &#123; // 布尔类型 boolT := true boolT = false fmt.Println(&quot;布尔类型的输出: &quot;, boolT) //布尔类型的输出: false // 关于数值类型的说明 // 凡是带 u + 类型的均为 无符号类型 例如 uint8 是无符号的8位正整数 0-255 // int8类型 -128-127 // uint8类型 0 ~ 255 var int8T int8 = 127 var uint8T uint8 = 255 // 指定的类型不能超出数值范围，否则发生overflow 其他的类型同理 //var int8T int8 = 128 //constant 128 overflows int8v fmt.Println(&quot;8位数值的类型的输出: &quot;, int8T) fmt.Println(&quot;无符号8位数值的类型的输出: &quot;, uint8T) /** 8位数值的类型的输出: 127 无符号8位数值的类型的输出: 255 */ //int16 -32768～32767 //uint16 0～65535 var int16T int16 = 127 var uint16T uint16 = 65535 fmt.Println(&quot;int16T 的类型的输出: &quot;, int16T) fmt.Println(&quot;uint16T 的类型的输出: &quot;, uint16T) /** int16T 的类型的输出: 127 uint16T 的类型的输出: 65535 */ //int32 ：-2147483648～2147483647 //uint32 : 0～4294967295 var int32T int32 = 2147483647 var uint32T uint32 = 4294967295 fmt.Println(&quot;int32T 的类型的输出: &quot;, int32T) fmt.Println(&quot;uint32T 的类型的输出: &quot;, uint32T) /** int32T 的类型的输出: 2147483647 uint32T 的类型的输出: 4294967295 */ //int64 : -9223372036854775808～9223372036854775807 //uint64: 0～18446744073709551615 var int64T int64 = 9223372036854775807 var uint64T uint64 = 18446744073709551615 fmt.Println(&quot;int64T 的类型的输出: &quot;, int64T) fmt.Println(&quot;uint64T 的类型的输出: &quot;, uint64T) /** int64T 的类型的输出: 9223372036854775807 uint64T 的类型的输出: 18446744073709551615 */ // int 和 uint 都是根据系统的位数自行调节 // 32 位系统 : -2147483648～2147483647 // 64 位系统 : -9223372036854775808～9223372036854775807 var intT int = 9223372036854775807 //uint：表示 32 或 64 位无符号整型。(取决于系统的位数) // 32 位系统 ： 0～4294967295， // 64 位系统 ： 0～18446744073709551615 var uintT uint = 18446744073709551615 fmt.Println(&quot;intT 的类型的输出: &quot;, intT) fmt.Println(&quot;uintT 的类型的输出: &quot;, uintT) /** intT 的类型的输出: 9223372036854775807 uintT 的类型的输出: 18446744073709551615 */ /** Float 数值类型 */ // float32 3.402823466385288598117041834516925440e +38 1.401298464324817070923729583289916131280e -45 // float32 大约可提供6位小数 1 左移 24位 var float32T float32 = 16777216 // IEEE754 // 因float32 累计计算扩散 请尽量使用float64 fmt.Println(&quot;float32T 的类型的输出: &quot;, float32T == float32T+1) var float64T float64 = 16777216 fmt.Println(&quot;float64T 的类型的输出: &quot;, float64T == float64T+1) const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 fmt.Println(&quot;阿伏伽德罗常数：&quot;, Avogadro, &quot;普朗克常数：&quot;, Planck) // 默认情况下 float推断 均为float64 fl64 := 1.11 fmt.Printf(&quot;Float 类型推断： %T \n&quot;, fl64) // 复数类型 // 用途 ： 反常积分 ,分析系统稳定性的根轨迹法 ，奈奎斯特图法（Nyquist plot）和尼科尔斯图法（Nichols plot）都是在复平面上进行的 //complex64：实和虚 都为 float32 类型的的复数。 //complex128：实和虚 都为 float64 类型的的复数。 c1 := complex(1, 2) c2 := 3 + 4i cadd := c1 + c2 fmt.Println(&quot;复数和:&quot;, cadd) cmul := c1 * c2 fmt.Println(&quot;复数:&quot;, cmul) // byte 是 uint8 的别名。 utf8编码 // 声明数组 // ASCII 码 49 50 51 52 data := [4]byte&#123;0x31, 0x32, 0x33, 0x34&#125; str := string(data[:]) fmt.Println(&quot;byte 转 string :&quot;, str) // 使用rune 和获取 字符串长度 fmt.Println(&quot;rune string 长度 :&quot;, utf8.RuneCountInString(str)) // rune 是 int32 的别名。 str1 := &quot;我叫MT&quot; fmt.Println(&quot;rune 结果&quot;, []rune(str1)) fmt.Println(&quot;byte 结果&quot;, []byte(str1)) //const 关键字常量 初始化赋值 // 常量结果不能通过函数 方法赋值给常量 const constA = 100 fmt.Println(&quot;constA 结果&quot;, constA) // IOTA 常量 const ( a = iota //a=0 b = iota //b=1 c //c=2 _ //3 d //d=4 ) fmt.Println( &quot;a is :&quot;, a, &quot;b is :&quot;, b, &quot;c is :&quot;, c, &quot;d is :&quot;, d, ) // 实战用法 type ByteSize float64 const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 &lt;&lt; (10 * iota) // 1 &lt;&lt; (10*1) MB // 1 &lt;&lt; (10*2) GB // 1 &lt;&lt; (10*3) TB // 1 &lt;&lt; (10*4) PB // 1 &lt;&lt; (10*5) EB // 1 &lt;&lt; (10*6) ZB // 1 &lt;&lt; (10*7) YB // 1 &lt;&lt; (10*8) ) fmt.Println( &quot;KB is &quot;, KB, &quot;\n MB is &quot;, MB, &quot;\n GB is &quot;, GB, &quot;\n TB is &quot;, TB, &quot;\n PB is &quot;, PB, &quot;\n EB is &quot;, EB, &quot;\n EB is &quot;, EB, &quot;\n ZB is &quot;, ZB, &quot;\n YB is &quot;, YB, )&#125; 函数1234567891011121314151617181920package main//引入包import ( &quot;fmt&quot; &quot;github.com/pkg/errors&quot;)func main() &#123; fmt.Println(TestFunc(33)) fmt.Println(TestFunc(10))&#125;func TestFunc(i int) (err error, d int) &#123; if d := i % 10; d == 0 &#123; return nil, d &#125; return errors.New(&quot;无法对10取模&quot;), 0&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 断言，流程控制，运算]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-5%2F</url>
    <content type="text"><![CDATA[断言1234567891011121314package mainimport &quot;fmt&quot;//自定义类型type sw interface &#123;&#125;func main() &#123; // 给类型赋值 var s sw = 0x0D // 断言 fmt.Println(s.(int))&#125; if-else123456789101112131415161718192021222324252627282930313233343536373839404142434445 package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func main() &#123; var d int64 = 1200 fmt.Println(d) if d%10 != 1 &#123; fmt.Println(&quot;a&quot;) &#125; else &#123; fmt.Println(&quot;b&quot;) &#125; // i32 测试 var i32 int32 = 1200 str, err := test(i32) fmt.Println(str) // 空字符串 if err != nil &#123; fmt.Println(err) // 无法判断类型 &#125; //i64 测试 s, err := test(d) fmt.Println(s) // 您传入的是 ： 1200 if err != nil &#123; fmt.Println(err) // 不会发生错误 &#125;&#125;func test(i interface&#123;&#125;) (str string, err error) &#123; switch i.(type) &#123; case int64: sprintf := fmt.Sprintf(&quot;您传入的是 ： %d&quot;, i) return sprintf, nil &#125; return &quot;&quot;, errors.New(&quot;无法判断类型&quot;)&#125; for 循环1234567891011121314151617// 循环一百次for i:=1; i &lt;=100; i++ &#123; // 大于50停止循环 if i &gt; 50&#123; break; &#125; // 求于等于0 跳过 if i %2 == 0&#123; continue &#125;&#125;// 死循环//for &#123;// fmt.Println(time.Now().Second())// time.Sleep(time.Second * 3)//&#125; switch 选择123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; test := &quot;A&quot; switch test &#123; case &quot;A&quot;: fmt.Println(test) case &quot;B&quot;: fmt.Println(&quot;B&quot;) case &quot;C&quot;: fmt.Println(&quot;C&quot;) case &quot;Q&quot;, &quot;P&quot;: fmt.Println(&quot;Q,P&quot;) &#125; switch num := 99; &#123; case num &lt; 50: fmt.Printf(&quot;%d 小于 %d\n&quot;, num, 50) //跳转到下一个case fallthrough case num &lt; 100: fmt.Printf(&quot;%d 小于 %d\n&quot;, num, 100) //跳转到下一个case fallthrough case num &lt; 200: fmt.Printf(&quot;%d 小于 %d&quot;, num, 200) &#125;&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 数组，切片，Map, 字符串]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-6%2F</url>
    <content type="text"><![CDATA[数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package mainimport ( &quot;fmt&quot; &quot;github.com/pkg/errors&quot;)func main() &#123; // 初始化数组 默认为0 var arri32 [10]int32 fmt.Println(arri32) // 输出 [0 0 0 0 0 0 0 0 0 0] arri32[1] = 10 arri32[9] = 10 fmt.Println(arri32) // 输出 [0 10 0 0 0 0 0 0 0 10] // 直接初始化数组值 var arri = [5]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(arri) //[1 2 3 4 5] // 自动计算长度 var arra = [...]int&#123;5, 4, 3, 2, 1&#125; fmt.Println(arra) // [5 4 3 2 1] //相同长度相同类型的数组可以直接赋值 // 变更arri 1-5 为 5-1 arri = arra fmt.Println(arri) //[5 4 3 2 1] // 值类型传递 arra[2] = 18 fmt.Println(arra) fmt.Println(arri) //[5 4 18 2 1] //[5 4 3 2 1] // 上面 arra 赋值给 arri 之后 arra发生变化 arri 还是保持原样 // 赋值复制整个数组，为值传递 // 传递给方法 或者函数时，也是如此 // 数组长度 fmt.Println(len(arra)) // 长度为 5 // 循环数组内容 for i, i2 := range arra &#123; fmt.Println(&quot;数组下标: &quot;, i, &quot;数组值: &quot;, i2) &#125; // or for i := 0; i &lt; len(arra); i++ &#123; fmt.Println(&quot;数组下标: &quot;, i, &quot;数组值: &quot;, arra[i]) &#125; // 多维数组 arrm := [3][3]string&#123; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &#123;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125;, &#123;&quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;, &#125; // 查找出现的位置 r, c, err := search(arrm[:][:], 3, 3, &quot;6&quot;) fmt.Println(&quot;第&quot;, r, &quot;行 第 c : &quot;, c, &quot;列&quot;, &quot;错误信息：&quot;, err) //第 2 行 第 c : 3 列 错误信息： &lt;nil&gt;&#125;// 自定义查找一个多行多列的数组中的值位置func search(a [][3]string, row, col int, key string) (r, c int, err error) &#123; if row &lt; 0 || col &lt; 0 &#123; return 0, 0, errors.New(&quot;空的&quot;) &#125; // 循环递增的行数 rowNum := 0 // 循环递增的列数，由外部传入后 - 1得知 colNum := col - 1 // 当前循环行 小于 grid 行 且 列数不为0 for rowNum &lt; row &amp;&amp; colNum &gt;= 0 &#123; // 判断等于 key 值 if a[rowNum][colNum] == key &#123; // 返回下标 return rowNum + 1, colNum + 1, nil &#125; else &#123; rowNum++ &#125; &#125; return&#125; 切片1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; arrm := [3][3]string&#123; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &#123;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125;, &#123;&quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;, &#125; // 切片初始化 var slia [][3]string = arrm[1:] fmt.Println(slia) //[[4 5 6] [7 8 9]] var slic = []string&#123;&quot;10&quot;, &quot;11&quot;, &quot;12&quot;&#125; fmt.Println(slic) // [10 11 12] // make 方式创建切片 slid := make([]int, 10, 10) fmt.Println(slid) //[0 0 0 0 0 0 0 0 0 0] slice := slid[1:6] // 从1-5 截取 fmt.Printf(&quot;Slice 长度为 %d capacity 为 %d \n&quot;, len(slice), cap(slice)) // slice 从 slid 创建 // 索引从1开始 到 第10位 10 -1 = 9 的capacity // 同理 slid[2:6] 则为 10 -2 =8 的 capacity // 复制切片 释放原切片数组 en24 := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125; countslice := en24[1:3] copySlice := make([]string, 10) copy(copySlice, countslice) // 释放en24&#125; map12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; // 创建map mapT := make(map[string]interface&#123;&#125;, 10) // Map 添加值 mapT[&quot;key&quot;] = &quot;val&quot; // 打印map fmt.Println(mapT) // 获取指定的map值 fmt.Println(mapT[&quot;key&quot;]) fmt.Println(len(mapT)) //map[key:val] //val // 删除 delete(mapT, &quot;key&quot;) fmt.Println(mapT) //map[]&#125; string 字符串12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;func main() &#123; str := &quot;String&quot; fmt.Println(str) for i := 0; i &lt; len(str); i++ &#123; // 打印 hex fmt.Printf(&quot;%x &quot;, str[i]) &#125; fmt.Println() str = &quot;我爱中国&quot; for i := 0; i &lt; len(str); i++ &#123; // 打印 char fmt.Printf(&quot;%c &quot;, str[i]) &#125; fmt.Println() // rune runeString := []rune(str) for i := 0; i &lt; len(runeString); i++ &#123; // 打印 char fmt.Printf(&quot;%c &quot;, runeString[i]) &#125; // or fmt.Println() for _, i2 := range runeString &#123; // 打印 char fmt.Printf(&quot;%c &quot;, i2) &#125;&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 结构，方法，接口, 指针]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-7%2F</url>
    <content type="text"><![CDATA[结构，方法, 指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164package mainimport ( &quot;encoding/json&quot; &quot;errors&quot; &quot;fmt&quot;)// 接口type SoftDelete interface &#123; delete(id uint64) (bool, error)&#125;type Base struct &#123; // 声明ID 类型int64 // ``包裹的是 Tag注释 由 reflection 反射获取 // 序列化时 json 为id, omitempty 可以为空 ID uint64 `json:&quot;id,omitempty&quot;`&#125;// 声明一个User 结构体type User struct &#123; // 结构体嵌套 Base Username string `json:&quot;username,omitempty&quot;` // 非导出字段 // 非user包 无法访问该属性 password string `json:&quot;password,omitempty&quot;` // 结构体嵌套 UserAddress []UserAddress `json:&quot;address,omitempty&quot;`&#125;//type UserAddress struct &#123; Base PhoneNumber string `json:&quot;phone_number,omitempty&quot;` Address string `json:&quot;address,omitempty&quot;` Lat float64 `json:&quot;lat,omitempty&quot;` Lon float64 `json:&quot;lat,omitempty&quot;`&#125;// 值方法func (us User) delete(id uint64) (bool, error) &#123; if id &gt; 0 &#123; us.ID = 0 us.Username = &quot;&quot; fmt.Println(&quot;正确的ID已删除&quot;) return true, nil &#125; fmt.Println(&quot;错误的ID，无法删除&quot;) return false, errors.New(&quot;错误的ID，无法删除&quot;)&#125;// 指针 方法func (uad *UserAddress) delete(id uint64) (bool, error) &#123; if id &gt; 0 &#123; uad.ID = 0 uad.Address = &quot;&quot; fmt.Println(&quot;正确的ID已删除&quot;) return true, nil &#125; fmt.Println(&quot;错误的ID，无法删除&quot;) return false, errors.New(&quot;错误的ID，无法删除&quot;)&#125;func main() &#123; var user User user.ID = 1 user.Username = &quot;admin&quot; // 本包内可以访问数据 user.password = &quot;123123&quot; var userAddress = make([]UserAddress, 3, 10) // var 方式设置结构体 var u UserAddress u.ID = 1 u.PhoneNumber = &quot;1339222101&quot; u.Address = &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; u.Lat = 30.6179363100 u.Lon = 114.2626900300 userAddress = append(userAddress, u) // 直接初始化结构体 userAddress = append(userAddress, UserAddress&#123; // 嵌套结构体直接初始化，必须要给定结构体 Base: Base&#123;ID: 2&#125;, PhoneNumber: &quot;1339222101&quot;, Address: &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot;, Lat: 30.6179363100, Lon: 114.2626900300, &#125;) // new 方式初始化 u2 := new(UserAddress) u2.ID = 3 u.PhoneNumber = &quot;1339222101&quot; u.Address = &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; u.Lat = 30.6179363100 u.Lon = 114.2626900300 user.UserAddress = userAddress fmt.Println(user) fmt.Println() fmt.Println() marshal, _ := json.Marshal(user) fmt.Println(string(marshal)) /** &#123; &quot;id&quot;: 1, &quot;username&quot;: &quot;admin&quot;, &quot;address&quot;: [ &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123; &quot;id&quot;: 1, &quot;phone_number&quot;: &quot;1339222101&quot;, &quot;address&quot;: &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;phone_number&quot;: &quot;1339222101&quot;, &quot;address&quot;: &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; &#125; ] &#125; */ // 输出时无password字段 b, err := u2.delete(0) fmt.Println(&quot;u2 删除结果 &quot;, b, &quot;err 信息：&quot;, err) fmt.Println(u2.ID) //错误的ID，无法删除 //u2 删除结果 false err 信息： 错误的ID，无法删除 b, err = u2.delete(1) fmt.Println(&quot;u2 删除结果 &quot;, b, &quot;err 信息：&quot;, err) // 指针接受者则会变更内容 fmt.Println(u2) //正确的ID已删除 //u2 删除结果 true err 信息： &lt;nil&gt; b2, err := user.delete(0) fmt.Println(&quot;user 删除结果 &quot;, b2, &quot;err 信息：&quot;, err) bytes, err := json.Marshal(user) fmt.Println(string(bytes)) b2, err = user.delete(1) fmt.Println(&quot;user 删除结果 &quot;, b2, &quot;err 信息：&quot;, err) bytes, err = json.Marshal(user) fmt.Println(string(bytes)) // user.ID 并没有被重置 // 接口调用 var I1 SoftDelete = user I1.delete(0) I1.delete(1) var I2 SoftDelete = u2 I2.delete(0) I2.delete(1)&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. 协程，频道，select, WaitGroup && mutex]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-8%2F</url>
    <content type="text"><![CDATA[CSP12什么是协程OS 并不理解 协程，协程是在 用户层 模拟出来的调度，协程运行在线程之上，所以协程没有上下文切换消耗。 协程，频道12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport ( &quot;fmt&quot; &quot;time&quot;)// 感兴趣的朋友可以去了解一下func main() &#123; // 协程 go func() &#123; fmt.Println(&quot;现在时间是:&quot;, time.Now().String()) &#125;() // 并没有任何输出 // golang 协程已经启动了，发生了什么无法打印现在时间呢 // 事实上 go主进程 不会等待 go 协程执行完， 主进程调用go 协程后会顺序执行你的下一步代码 // 所以，上述代码 调用协程后，主进程 执行下一步代码，因为下一步代码 没有之后，主进程生命周期完结退出了 // 让主进程等待几秒钟 查看go 协程的打印信息 time.Sleep(time.Second * 3) // 等待后，你会发现协程中的打印可以正常输出了 // 现在时间是: 2020-03-28 17:02:20.059775 +0800 CST m=+0.000452348 // Channel 双向频道 长度为5或者可缓冲长度 var gochan = make(chan string, 5) go func() &#123; // 协程执行，并将消息发送到频道信息中 gochan &lt;- &quot;chan 打印时间&quot; + time.Now().String() &#125;() // 如果无人接收该频道值则会发生死锁 fmt.Println(&lt;-gochan) // 此时通过频道获取数据 // 打印数据为：chan 打印时间2020-03-28 17:15:09.589493 +0800 CST m=+3.000244013 // 只写频道：chan&lt;- T // chan 后面 有箭头则是写入方向 var goschan = make(chan&lt;- string, 5) goschan &lt;- &quot;可以写入&quot; // 打印chan的地址 fmt.Println(goschan) // 尝试接收打印时，IDE会报错 //fmt.Println(&lt;-goschan) // 那么这个该怎么用呢 // 首先声明一个 双向的chanel // 这里直接使用上的gochan 双向的 频道 onlySend(gochan) fmt.Println(&lt;-gochan) // 你好，现在是北京时间2020-03-28 17:26:23.318116 +0800 CST m=+3.002332002 // 只读频道：&lt;-chan T //chan 前面有箭头则是读取方向 /*var gorchan = make(&lt;-chan string, 5) fmt.Println(&lt;-gorchan)*/ //这样写会提示报错 fatal error: all goroutines are asleep - deadlock! //因为单向的只读chan 没有数据可读 产生死锁 //那么单向的只读chan该如何使用呢 // 使用双向chan 与只写类似 // 这里直接使用上的gochan 双向的 频道 gochan &lt;- &quot;只读的Chan 读取数据啦&quot; // 注意此时的gochan不存在数据，一样会造成死锁，所以在此之前，我们发送一个消息到chan中 onlyRead(gochan) // 此时只读chan 正常运行打印了 // 只读的Chan 读取数据啦&#125;func onlyRead(read &lt;-chan string) &#123; fmt.Println(&lt;-read)&#125;// 限制只允许发送信息，不允许接收信息func onlySend(say chan&lt;- string) &#123; say &lt;- &quot;你好，现在是北京时间&quot; + time.Now().String()&#125; Select1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;time&quot;)func ConsoleInfo(c chan string) &#123; for i := 0; i &lt; 10; i++ &#123; c &lt;- &quot;当前打印 : &quot; + strconv.Itoa(i) &#125;&#125;func main() &#123; ch := make(chan string, 10) go ConsoleInfo(ch) var count = 0 for &#123; select &#123; case curr := &lt;-ch: fmt.Println(&quot;接受到的消息： &quot;, curr) count++ if count &gt;= 10 &#123; return &#125; case &lt;-time.After(time.Second * 1): fmt.Println(&quot;timeout&quot;) default: fmt.Println(&quot;没有接收到数据&quot;) &#125; &#125;&#125; WaitGroup &amp;&amp; mutex123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var count = 0func main() &#123; var w sync.WaitGroup var m sync.Mutex for i := 1; i &lt;= 100; i++ &#123; w.Add(1) go func() &#123; // 加锁操作 m.Lock() count = count + 1 // 操作完成 解锁 m.Unlock() w.Done() &#125;() &#125; w.Wait() fmt.Println(&quot;最终值为：&quot;, count)&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervisor 保活进程工具]]></title>
    <url>%2F2018%2F02%2F13%2F%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88-supervisor%2F</url>
    <content type="text"><![CDATA[TL;DR; 就是标题 什么是supervisorsuperviosr是一个Linux/Unix系统上的进程监控工具，他/她upervisor是一个Python开发的通用的进程管理程序，可以管理和监控Linux上面的进程，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。不过同daemontools一样，它不能监控daemon进程 为什么用supervisor使用简单supervisor提供了一种统一的方式来start、stop、monitor你的进程， 进程可以单独控制，也可以成组的控制。你可以在本地或者远程命令行或者web接口来配置Supervisor。在linux下的很多程序通常都是一直运行着的，一般来说都需要自己编写一个能够实现进程start/stop/restart/reload功能的脚本，然后放到/etc/init.d/下面。但这样做也有很多弊端，第一我们要为每个程序编写一个类似脚本，第二，当这个进程挂掉的时候，linux不会自动重启它的，想要自动重启的话，我们还要自己写一个监控重启脚本。而supervisor则可以完美的解决这些问题。supervisor管理进程，就是通过fork/exec的方式把这些被管理的进程，当作supervisor的子进程来启动。这样的话，我们只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去就OK了。第二，被管理进程作为supervisor的子进程，当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，所以当然也就可以对挂掉的子进程进行自动重启，当然重启还是不重启，也要看你的配置文件里面有木有设置autostart=true了。supervisor通过INI格式配置文件进行配置，很容易掌握，它为每个进程提供了很多配置选项，可以使你很容易的重启进程或者自动的轮转日志。 集中管理supervisor管理的进程，进程组信息，全部都写在一个ini格式的文件里就OK了。而且，我们管理supervisor的时候的可以在本地进行管理，也可以远程管理，而且supervisor提供了一个web界面，我们可以在web界面上监控，管理进程。 当然了，本地，远程和web管理的时候，需要调用supervisor的xml_rpc接口，这个也是后话。supervisor可以对进程组统一管理，也就是说咱们可以把需要管理的进程写到一个组里面，然后我们把这个组作为一个对象进行管理，如启动，停止，重启等等操作。而linux系统则是没有这种功能的，我们想要停止一个进程，只能一个一个的去停止，要么就自己写个脚本去批量停止。 supervisor组成supervisord 主进程主进程,负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时内置web server和XML-RPC Interface，轻松实现进程管理。。该服务的配置文件在/etc/supervisor/supervisord.conf。 supervisorctl 外部控制器客户端的命令行工具，提供一个类似shell的操作接口，通过它你可以连接到不同的supervisord进程上来管理它们各自的子程序，命令通过UNIX socket或者TCP来和服务通讯。用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。服务端也可以要求客户端提供身份验证之后才能进行操作。 Web Server web控制器superviosr提供了web server功能，可通过web控制进程(需要设置[inethttpserver]配置项)。 RPC控制器XML-RPC接口， 就像HTTP提供WEB UI一样，用来控制supervisor和由它运行的程序。 安装1234567pip install supervisor// 创建配置文件mkdir /etc/supervisorecho_supervisord_conf &gt; /etc/supervisor/supervisord.conf// 运行supervisorsupervisord -c /etc/supervisor/supervisord.conf 配置supervisord.conf 去除注释12[include]files = /etc/supervisor/conf.d/*.conf 比如说之前 mysql MHA方式搭建时123// 后台运行HA监控管理服务器nohup masterha_manager --conf=/etc/mastermha/app1.conf --remove_dead_master_conf \--ignore_fail_on_start --ignore_last_failover &amp; 我们可以将其改造到supervisor 12345678910111213[program:test_http]command=masterha_manager --conf=/etc/mastermha/app1.conf --remove_dead_master_conf \--ignore_fail_on_start --ignore_last_failover; 被监控的进程路径;directory=/root/temp ; 执行前要不要先cd到目录去，一般不用priority=1 ;数字越高，优先级越高numprocs=1 ; 启动几个进程autostart=true ; 随着supervisord的启动而启动autorestart=true ; 自动重启。。当然要选上了startretries=10 ; 启动失败时的最多重试次数exitcodes=0 ; 正常退出代码（是说退出代码是这个时就不再重启了吗？待确定）stopsignal=KILL ; 用来杀死进程的信号stopwaitsecs=10 ; 发送SIGKILL前的等待时间redirect_stderr=true ; 重定向stderr到stdout or 又或者是其他场景比如laravel 的队列 12345678910[program:laravel-worker]process_name=%(program_name)s_%(process_num)02ddirectory=/data/www/laravel command=php /artisan queue:work --tries=3autostart=trueautorestart=trueuser=vagrant ;运行用户numprocs=8 ; 启动几个进程redirect_stderr=truestdout_logfile=/var/log/supervisor/laravel-queue.log 配置清单样例123456789101112131415161718192021222324252627282930- command：启动程序使用的命令，可以是绝对路径或者相对路径- process_name：一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%(program_name)s- numprocs：Supervisor启动这个程序的多个实例，如果numprocs&gt;1，则process_name的表达式必须包含%(process_num)s，默认是1- numprocs_start：一个int偏移值，当启动实例的时候用来计算numprocs的值- priority：权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999- autostart：如果设置为true，当supervisord启动的时候，进程会自动重启。- autorestart：值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。- startsecs：程序启动后等待多长时间后才认为程序启动成功- startretries：supervisord尝试启动一个程序时尝试的次数。默认是3- exitcodes：一个预期的退出返回码，默认是0,2。- stopsignal：当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, or USR2。- stopwaitsecs：在操作系统给supervisord发送SIGCHILD信号时等待的时间- stopasgroup：如果设置为true，则会使supervisor发送停止信号到整个进程组- killasgroup：如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。- user：如果supervisord以root运行，则会使用这个设置用户启动子程序- redirect_stderr：如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。- stdout_logfile：把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。- stdout_logfile_maxbytes：标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小- stdout_logfile_backups：标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份- stdout_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB- stdout_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发- stderr_logfile：把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true- stderr_logfile_maxbytes：错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小- stderr_logfile_backups：错误日志轮转备份的数量，默认是10，如果设置为0，则不备份- stderr_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB- stderr_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发- environment：一个k/v对的list列表- directory：supervisord在生成子进程的时候会切换到该目录- umask：设置进程的umask- serverurl：是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url]]></content>
      <categories>
        <category>保活工具</category>
        <category>高可用方案</category>
      </categories>
      <tags>
        <tag>more HA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. defer, errors,panic, recover]]></title>
    <url>%2F2018%2F02%2F13%2Fgolang-golang-9%2F</url>
    <content type="text"><![CDATA[defer1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func incA() int &#123; var A int defer func() &#123; A++ &#125;() return A&#125;func incB() (B int64) &#123; defer func() &#123; B++ &#125;() return B&#125;/**1.defer是栈调用，后写的先执行2.defer的函数调用语句会在父函数调用后执行，但是用到的参数会在当时就执行得出*/func main() &#123; fmt.Println(incA()) fmt.Println(incB()) fmt.Println(&quot;--------------------&quot;) defer func() &#123; fmt.Println(incA()) &#125;() defer func() &#123; defer func() &#123; fmt.Println(incB()) &#125;() &#125;()&#125; errors,panic recover1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;errors&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; fmt.Println(errors.New(&quot;你得罪了你的女朋友！&quot;)) fmt.Println(errors.New(&quot;你还一直不懂味！！！&quot;)) fmt.Println(errors.New(&quot;还是和往常一样在飞快的处理 err&quot;)) fmt.Println(&quot;你准备打开这本恋爱修炼手册&quot;) f, err := os.Open(&quot;/恋爱修炼手册.txt&quot;) if err != nil &#123; fmt.Println(&quot;其实你并没有这本书&quot;) &#125; else &#123; fmt.Println(f.Name(), &quot;你打开了潘多拉魔盒&quot;) &#125; fmt.Println(errors.New(&quot;直到有一天，你的生活发生了改变&quot;)) fmt.Println(fmt.Errorf(&quot;你的女朋友问你，你是否还爱她. 你给出了答案： %s&quot;, &quot;你爱过大海，我爱过你&quot;)) fmt.Println(&quot;你在说这句话的时候，其实你已经准备好了向她求婚...&quot;) defer func() &#123; if r := recover(); r != nil &#123; fmt.Println(&quot;醒醒吧，你没有女朋友，程序员哪来的女朋友&quot;) &#125; &#125;() fmt.Println(&quot;无法继续生活下去了&quot;) panic(&quot;分手！！！&quot;)&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-大表优化-数据归档]]></title>
    <url>%2F2018%2F02%2F13%2Fmysql-mysql-percona%2F</url>
    <content type="text"><![CDATA[服务环境： Centos7.2.1511 percona-toolkit-3.0 123信息 数据库IP地址 库名 表名主数据库 10.58.107.46 unix sbtest01 归档数据库 10.58.107.46 unix sbtest_archiver 1当一个表超过千万行的时候就会对数据库性能造成影响，但如果仅有INSERT操作和少量的SELECT操作,几乎没有UPDATE和DELETE操作的话，相对来说对数据库的性能影响不算很大。 安装及使用方法：安装percona-toolkit12wget https://www.percona.com/downloads/percona-toolkit/3.0.11/binary/redhat/7/x86_64/percona-toolkit-3.0.11-1.el7.x86_64.rpmyum localinstall percona-toolkit-3.0.11-1.el7.x86_64.rpm 创建归档表123注：以下是归档示例，数据库是unix，归档的表是sbtest01 ，归档到 sbtest_archiver表中。use unix;create table sbtest_archiver like sbtest1 ; 使用percona做数据库归档123456注：以下归档命令是把数据归档完之后，并删除掉老的数据，如果用于线上执行前请慎重，如果做完归档不想删除掉老的数据可以使用no-delete参数pt-archiver \--source h=10.58.107.46,P=3306,u=monitor,p=123123,D=unix,t=sbtest1 \--dest h=10.58.107.46,P=3306,u=monitor,p=123123,D=unix,t=sbtest_archiver \--where &apos;id &lt;= 10000&apos; --limit=1000 --txn-size=1000 \--statistics --charset=utf8 参数详解123--no-delete #归档时不删除老数据--limit #表示每次事务删除的行数--txn-size #每个事务提交的行数（读写）]]></content>
      <categories>
        <category>mysql</category>
        <category>高可用方案</category>
      </categories>
      <tags>
        <tag>more HA</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pm2 保活进程工具]]></title>
    <url>%2F2018%2F02%2F13%2F%E4%BF%9D%E6%B4%BB%E6%96%B9%E6%A1%88-p2%2F</url>
    <content type="text"><![CDATA[使用pm2自动化部署node项目pm2简介pm2（process manager）是一个进程管理工具，维护一个进程列表，可以用它来管理你的node进程，负责所有正在运行的进程，并查看node进程的状态，也支持性能监控，负载均衡等功能。 使用pm2管理的node程序的好处监听文件变化，自动重启程序支持性能监控负载均衡程序崩溃自动重启服务器重新启动时自动重新启动自动化部署项目 pm2安装与使用全局安装1npm install pm2 -g 常用命令启动一个node程序 1pm2 start start.js 启动进程并指定应用的程序名 1pm2 start app.js --name application1 集群模式启动 123// -i 表示 number-instances 实例数量// max 表示 PM2将自动检测可用CPU的数量 可以自己指定数量pm2 start start.js -i max 添加进程监视 12// 在文件改变的时候会重新启动程序pm2 start app.js --name start --watch 列出所有进程 12pm2 listpm2 ls // 简写 从进程列表中删除进程 123pm2 delete [appname] | idpm2 delete app // 指定进程名删除pm2 delete 0 // 指定进程id删除 删除进程列表中所有进程 1pm2 delete all 查看某个进程具体情况 1pm2 describe app 查看进程的资源消耗情况 1pm2 monit 重启进程 12pm2 restart app // 重启指定名称的进程pm2 restart all // 重启所有进程 查看进程日志 12pm2 logs app // 查看该名称进程的日志pm2 logs all // 查看所有进程的日志 设置pm2开机自启 开启启动设置，此处是CentOS系统，其他系统替换最后一个选项（可选项：ubuntu, centos, redhat, gentoo, systemd, darwin, amazon） 1pm2 startup centos 然后按照提示需要输入的命令进行输入 最后保存设置 1pm2 save 通过pm2配置文件来自动部署项目确保服务器安装了pm2，没有安装的话先安装1npm install pm2 -g 在项目根目录下新建一个 deploy.yaml 文件deploy.yaml123456789101112131415161718192021apps: - script: ./start.js # 入口文件 name: &apos;app&apos; # 程序名称 env: # 环境变量 COMMON_VARIABLE: true env_production: NODE_ENV: productiondeploy: # 部署脚本 production: # 生产环境 user: lentoo # 服务器的用户名 host: 192.168.2.166 # 服务器的ip地址 port: 22 # ssh端口 ref: origin/master # 要拉取的git分支 ssh_options: StrictHostKeyChecking=no # SSH 公钥检查 repo: https://github.com/**.git # 远程仓库地址 path: /home # 拉取到服务器某个目录下 pre-deploy: git fetch --all # 部署前执行 post-deploy: npm install &amp;&amp; pm2 reload deploy.yaml --env production # 部署后执行 env: NODE_ENV: production 配置git的ssh免密认证在服务器中生成rsa公钥和私钥，当前是 centos7 下进行 前提服务器要安装git，没有安装的先安装git，已安装的跳过 1yum –y install git 生成秘钥 1ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 在~/.ssh目录下有 id_rsa和 id_rsa.pub两个文件，其中id_rsa.pub文件里存放的即是公钥key。 登录到GitHub，点击右上方的头像，选择settings ，点击Add SSH key，把id_rsa.pub的内容复制到里面即可。 使用pm2部署项目每次部署前先将本地的代码提交到远程git仓库 首次部署 1pm2 deploy deploy.yaml production setup 部署完成后，既可登陆服务器查看配置的目录下是否从git上拉取了项目 再次部署 1pm2 deploy deploy.yaml production update 该部署流程同样适用前端项目如vue-cli的项目，自动部署到服务器，自动执行npm run build 命令，生成的dist目录，指定到nginx的静态文件目录下。 可能会遇到的坑在window系统下 vscode的命令行程序，以及powershell执行部署的命令时，出现部署失败 1pm2 deploy deploy.yaml production setup 解决方案：使用git命令行来执行]]></content>
      <categories>
        <category>保活工具</category>
        <category>高可用方案</category>
      </categories>
      <tags>
        <tag>more HA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL架构-MHA搭建部署]]></title>
    <url>%2F2018%2F02%2F13%2Fmysql-mysql-mha%2F</url>
    <content type="text"><![CDATA[系统环境： centos 7.2.1511 mysql 5.7.24-27 mha4mysql-manager 0.58 mha4mysql-node 0.58 1MHA 是较为常用的数据库中的高可用架构，以下部署是基于主从已经部署部署完毕的情况下搭建的。 部署搭建需要注意：mysql服务需要设置： relay_log_purge=0 所有MySQL数据库节点中添加定时任务：100 04 * * * /usr/bin/purge_relay_logs --user=ha_monitor --password=123123 --disable_relay_log_purge &amp;&gt;&gt; /var/purge_relay_logs.log 配置SSH认证1证书生成、公钥分发及依赖安装需要在每个节点上执行 生成证书1ssh-keygen 分发公钥到所有节点1234ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.17.0.55ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.17.0.56ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.17.0.57ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.17.0.58 安装依赖123yum install epel-release -yyum install perl-DBD-MySQL perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager \perl-Time-HiRes perl-devel perl-devel perl-CPAN -y 创建相关目录1/home/masterha/ 目录需要在所有节点创建， /etc/mastermha/仅在ha-monitor节点中创建 12mkdir -p /etc/mastermha/mkdir -p /home/masterha/ 下载MHA组件1所有节点需要安装mha node 节点，仅manager需要安装在ha-monitor节点上 1234wget \https://github.com/yoshinorim/mha4mysql-node/releases/download/v0.58/mha4mysql-node-0.58-0.el7.centos.noarch.rpmwget \https://github.com/yoshinorim/mha4mysql-manager/releases/download/v0.58/mha4mysql-manager-0.58-0.el7.centos.noarch.rpm 在所有节点上安装mha-node 组件：1yum localinstall mha4mysql-node-0.58-0.el7.centos.noarch.rpm -y 在ha-monitor节点上安装mha4mysql-manager 组件：1yum localinstall mha4mysql-manager-0.58-0.el7.centos.noarch.rpm -y 创建监控用户：12mysql&gt; CREATE USER &apos;ha_monitor&apos;@&apos;172.17.0.%&apos; IDENTIFIED BY &apos;123123&apos;;mysql&gt; GRANT ALL ON *.* TO &apos;ha_monitor&apos;@&apos;172.17.0.%&apos; ; 在ha-monitor节点添加配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253cat &gt; /etc/mastermha/app1.conf &lt;&lt; EOF[server default]#授权的manager监控用号和密码user=ha_monitorpassword=123123#MySQL服务复制用户和密码repl_user=syncrepl_password=123123# ssh远程登录用户和端口ssh_user=rootssh_port=22# 检测主master存活间隔和类型ping_interval=1ping_type=SELECT#管理端log路径manager_log=/home/masterha/manager.log#管理服务端所使用的目录manager_workdir=/home/masterha/#远程节点工作目录remote_workdir=/home/masterha/#数据库binlog目录master_binlog_dir=/data/mysql_3306_core/log/binary_log#故障failover脚本，需在官网的基础上修改配置master_ip_failover_script=/usr/local/bin/master_ip_failovermaster_ip_online_change_script=/usr/local/bin/master_ip_online_change#检测路由主master是否宕机secondary_check_script=&quot;masterha_secondary_check -s 172.17.0.56 -s 172.17.0.57&quot;[server1]hostname=172.17.0.56port=3306candidate_master=1[server2]hostname=172.17.0.57port=3306#设置可参数选举为MYSQL MASTERcandidate_master=1#忽略延迟check_repl_delay=0[server3]hostname=172.17.0.58port=3306#不参与选举no_master=1EOF 在ha-monitor节点下载相关脚本并修改相关信息：下载相关脚本1234wget https://down.niknk.com/MYSQL/master_ip_failoverwget https://down.niknk.com/MYSQL/master_ip_online_changemv master_ip_* /usr/local/bin/chmod +x /usr/local/bin/master_ip_* 修改master_ip_failover、master_ip_online_change中的参数信息123my $vip = &apos;172.17.0.100&apos;; #配置虚拟IPmy $gateway = &apos;172.17.0.1&apos;; #配置网关my $interface = &apos;eth0&apos;; #配置网卡名称 测试SSH及主从复制是否正常：12masterha_check_ssh --conf=/etc/mastermha/app1.confmasterha_check_repl --conf=/etc/mastermha/app1.conf 启动HA监控管理服务器：12nohup masterha_manager --conf=/etc/mastermha/app1.conf --remove_dead_master_conf \--ignore_fail_on_start --ignore_last_failover &amp; 检查是否正常：1masterha_check_status --conf=/etc/mastermha/app1.conf 输出信息：app1 (pid:11522) is running(0:PING_OK), master:172.17.0.56 后续维护：其它操作：停止HA监控管理服务1masterha_stop --conf=/etc/mastermha/app1.conf 在线手动切换手动执行切换需要停止HA监控管理服务12masterha_master_switch --master_state=alive --new_master_host=172.17.0.56 \--orig_master_is_new_slave --conf=/etc/mastermha/app1.conf 宕机手动切换12masterha_master_switch --master_state=dead --new_master_host=172.17.0.57 \--orig_master_is_new_slave --conf=/etc/mastermha/app1.conf 重新加入节点过滤 CHANGE MASTER 的信息并修改密码，在新添加的MySQL节点服务添加即可 过滤CHANGE MASTER信息1grep &apos;CHANGE MASTER TO&apos; /home/masterha/manager.log 过滤出日志修改信息如下12345CHANGE MASTER TO MASTER_HOST=&apos;172.17.0.57&apos;,MASTER_PORT=3306,MASTER_AUTO_POSITION=1,MASTER_USER=&apos;sync&apos;,MASTER_PASSWORD=&apos;123123&apos;; 在MHA配置文件中添加节点信息1234567vim /etc/mastermha/app1.conf[server1]candidate_master=1check_repl_delay=0hostname=172.17.0.56port=3306 重新测试SSH及主从复制是否正常12masterha_check_ssh --conf=/etc/mastermha/app1.confmasterha_check_repl --conf=/etc/mastermha/app1.conf 重新启动HA监控管理服务器12nohup masterha_manager --conf=/etc/mastermha/app1.conf --remove_dead_master_conf \--ignore_fail_on_start --ignore_last_failover &amp; 重新检查是否正常1masterha_check_status --conf=/etc/mastermha/app1.conf]]></content>
      <categories>
        <category>mysql</category>
        <category>高可用方案</category>
      </categories>
      <tags>
        <tag>more HA</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造高效的工作环境]]></title>
    <url>%2F2016%2F01%2F01%2FPHP-%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[用了一段时间的Mac系统， 记录一下使用心得在使用大多数环境时，为了偷懒更加偏向于Homebrew的依赖安装，省去了自己编译的方法，所以在开始的时候呢，首先说一下翻墙环境我使用的是SS + kcptun 的模式，由于大部分操作都是在终端环境，所以这里先来一个Proxy代理的方案 利器代理篇12345678910111213// 在终端中输入如下命令行export all_proxy=socks5://127.0.0.1:1080// 也可以分开TLS 和 HTTP访问export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;// git 操作 一般情况下访问国外才需要这么做，访问国内时可以切换回来，// 我也懒得改，反正是kcptun加速，也没有感觉git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global --unset http.proxygit config --global --unset https.proxy 如果你不想这么麻烦，可以选择 Proxifier 全局代理，当然在大多数情况下，有些软件不支持代理的话，可以选择 Proxifier 进行强制代理 Proxifier 下载地址 or 使用 proxychains4 当然你还可能会遇到，只支持HTTP代理的，那么可以选择 privoxy 将 socks5转换成HTTP 但我个人很少使用这种方式 利器浏览器篇当有了代理之后，SS如果选择全局代理的话感觉也不是很好可以走PAC，但我个人选择SwitchyOmega这里就不啰嗦了，推荐几个我觉得好用的 FeHelper 百度开发的Web前端助手 Adblock Plus 广告屏蔽，虽然没以前好用了，但是也还不错用习惯了 Octotree Github 浏览目录结构利器 Sourcegraph 比上面的强大的代码阅读理解工具 利器安装包篇有了代理之后，可以愉快的下载到各种你下载慢的东西了，比如说composer, npm i, git, docker等等一系列的 飞机一般的感受那么编译就成为了另一件大事了，NMP的环境编译一套下来整个人都懵了，那些乱七八糟的参数，我只想要一个开发环境，咋就那么难呢？为了偷懒，特地 google 了一下，原来Darwin系统还是有包管理的，类似linux 的yum or apt 题外话，如果你是windows的开发者，那么你有chocoWindows包管理 下载地址Win10的话也同样可以使用上面的办法安装一整套环境，或者你也可以使用WSL，毕竟Linux才是王道 1234567891011121314151617// 在开始之前挂上代理export all_proxy=socks5://127.0.0.1:1080// 使用Ruby获取Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;// Homebrew 更新brew update// 安装nginx brew install nginx// 安装PHP brew search php 因为homebrew core 迁移问题 php 5.6 低版本迁移问题，包括php5.6即将要终止维护的问题，将PHP迁移至其他子项目中所以先搜索一下或者你强制想要安装某个版本，那怎么办访问 PHP各个版本安装 12345就可以找到各个版本的安装方式执行一下// 我这里安装PHP5.6 是因为有老版本项目还得继续维护，非常讨厌5.6了brew install php@5.6// 中意的7.2安装brew install php@7.2 12345// 安装mysqlbrew install mysql// 安装nodejsbrew install node// 安装yarn composer 等等，只要你想的到的... Golang安装1brew install go 安装其他服务123456// 安装jenkinsbrew install jenkins// 安装etcdbrew install etcd// 安装consulbrew install consul 利器命令行篇在经历过 代理， 安装包 的痛苦之后，那么命令行又称为了懒人无法面对的事情，等等，我上一行命令是什么来着忘记了我好想记得是 git log xxxxx什么来着算了history看看吧，要不就一直up键找，直到找到为止，这样实在是太痛苦了后来又在网上逛了一圈，终于找到一个神器 ZSH 安装Oh-my-Zsh 使用CURL方式安装1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 使用Wget方式安装1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 安装后你会发现就只是变了个箭头而已，但是环境已经切到了ZSH上 ZSH自动提示插件 克隆仓库到当前用户的 ~/.zsh/zsh-autosuggestions. 1git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions 编辑 .zshrc 并向其中添加下面这行: 1source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 打开一个新的终端]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
</search>
