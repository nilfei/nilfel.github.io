<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[golang part3. 协程，频道，select, mutex]]></title>
    <url>%2F2020%2F03%2F28%2Fgolang-golang-8%2F</url>
    <content type="text"><![CDATA[CSP12什么是协程OS 并不理解 协程，协程是在 用户层 模拟出来的调度，协程运行在线程之上，所以协程没有上下文切换消耗。 协程，频道12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport ( &quot;fmt&quot; &quot;time&quot;)// 感兴趣的朋友可以去了解一下func main() &#123; // 协程 go func() &#123; fmt.Println(&quot;现在时间是:&quot;, time.Now().String()) &#125;() // 并没有任何输出 // golang 协程已经启动了，发生了什么无法打印现在时间呢 // 事实上 go主进程 不会等待 go 协程执行完， 主进程调用go 协程后会顺序执行你的下一步代码 // 所以，上述代码 调用协程后，主进程 执行下一步代码，因为下一步代码 没有之后，主进程生命周期完结退出了 // 让主进程等待几秒钟 查看go 协程的打印信息 time.Sleep(time.Second * 3) // 等待后，你会发现协程中的打印可以正常输出了 // 现在时间是: 2020-03-28 17:02:20.059775 +0800 CST m=+0.000452348 // Channel 双向频道 长度为5或者可缓冲长度 var gochan = make(chan string, 5) go func() &#123; // 协程执行，并将消息发送到频道信息中 gochan &lt;- &quot;chan 打印时间&quot; + time.Now().String() &#125;() // 如果无人接收该频道值则会发生死锁 fmt.Println(&lt;-gochan) // 此时通过频道获取数据 // 打印数据为：chan 打印时间2020-03-28 17:15:09.589493 +0800 CST m=+3.000244013 // 只写频道：chan&lt;- T // chan 后面 有箭头则是写入方向 var goschan = make(chan&lt;- string, 5) goschan &lt;- &quot;可以写入&quot; // 打印chan的地址 fmt.Println(goschan) // 尝试接收打印时，IDE会报错 //fmt.Println(&lt;-goschan) // 那么这个该怎么用呢 // 首先声明一个 双向的chanel // 这里直接使用上的gochan 双向的 频道 onlySend(gochan) fmt.Println(&lt;-gochan) // 你好，现在是北京时间2020-03-28 17:26:23.318116 +0800 CST m=+3.002332002 // 只读频道：&lt;-chan T //chan 前面有箭头则是读取方向 /*var gorchan = make(&lt;-chan string, 5) fmt.Println(&lt;-gorchan)*/ //这样写会提示报错 fatal error: all goroutines are asleep - deadlock! //因为单向的只读chan 没有数据可读 产生死锁 //那么单向的只读chan该如何使用呢 // 使用双向chan 与只写类似 // 这里直接使用上的gochan 双向的 频道 gochan &lt;- &quot;只读的Chan 读取数据啦&quot; // 注意此时的gochan不存在数据，一样会造成死锁，所以在此之前，我们发送一个消息到chan中 onlyRead(gochan) // 此时只读chan 正常运行打印了 // 只读的Chan 读取数据啦&#125;func onlyRead(read &lt;-chan string) &#123; fmt.Println(&lt;-read)&#125;// 限制只允许发送信息，不允许接收信息func onlySend(say chan&lt;- string) &#123; say &lt;- &quot;你好，现在是北京时间&quot; + time.Now().String()&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. 反射，IO, net/http]]></title>
    <url>%2F2020%2F03%2F28%2Fgolang-golang-10%2F</url>
    <content type="text"></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. 调度器]]></title>
    <url>%2F2020%2F03%2F28%2Fgolang-golang-11%2F</url>
    <content type="text"></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. 调度器]]></title>
    <url>%2F2020%2F03%2F28%2Fgolang-golang-12%2F</url>
    <content type="text"></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. 内存分配]]></title>
    <url>%2F2020%2F03%2F28%2Fgolang-golang-13%2F</url>
    <content type="text"></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part3. defer, errors,panic, recover]]></title>
    <url>%2F2020%2F03%2F28%2Fgolang-golang-9%2F</url>
    <content type="text"></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroService Part.1.1, 开启micro之路]]></title>
    <url>%2F2020%2F03%2F28%2Fgo-micro-part-1-1%2F</url>
    <content type="text"><![CDATA[获取Go micro安装配置环境实战分析参考资料]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>go-micro</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 数组，切片，Map, 字符串]]></title>
    <url>%2F2020%2F03%2F18%2Fgolang-golang-6%2F</url>
    <content type="text"><![CDATA[数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package mainimport ( &quot;fmt&quot; &quot;github.com/pkg/errors&quot;)func main() &#123; // 初始化数组 默认为0 var arri32 [10]int32 fmt.Println(arri32) // 输出 [0 0 0 0 0 0 0 0 0 0] arri32[1] = 10 arri32[9] = 10 fmt.Println(arri32) // 输出 [0 10 0 0 0 0 0 0 0 10] // 直接初始化数组值 var arri = [5]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(arri) //[1 2 3 4 5] // 自动计算长度 var arra = [...]int&#123;5, 4, 3, 2, 1&#125; fmt.Println(arra) // [5 4 3 2 1] //相同长度相同类型的数组可以直接赋值 // 变更arri 1-5 为 5-1 arri = arra fmt.Println(arri) //[5 4 3 2 1] // 值类型传递 arra[2] = 18 fmt.Println(arra) fmt.Println(arri) //[5 4 18 2 1] //[5 4 3 2 1] // 上面 arra 赋值给 arri 之后 arra发生变化 arri 还是保持原样 // 赋值复制整个数组，为值传递 // 传递给方法 或者函数时，也是如此 // 数组长度 fmt.Println(len(arra)) // 长度为 5 // 循环数组内容 for i, i2 := range arra &#123; fmt.Println(&quot;数组下标: &quot;, i, &quot;数组值: &quot;, i2) &#125; // or for i := 0; i &lt; len(arra); i++ &#123; fmt.Println(&quot;数组下标: &quot;, i, &quot;数组值: &quot;, arra[i]) &#125; // 多维数组 arrm := [3][3]string&#123; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &#123;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125;, &#123;&quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;, &#125; // 查找出现的位置 r, c, err := search(arrm[:][:], 3, 3, &quot;6&quot;) fmt.Println(&quot;第&quot;, r, &quot;行 第 c : &quot;, c, &quot;列&quot;, &quot;错误信息：&quot;, err) //第 2 行 第 c : 3 列 错误信息： &lt;nil&gt;&#125;// 自定义查找一个多行多列的数组中的值位置func search(a [][3]string, row, col int, key string) (r, c int, err error) &#123; if row &lt; 0 || col &lt; 0 &#123; return 0, 0, errors.New(&quot;空的&quot;) &#125; // 循环递增的行数 rowNum := 0 // 循环递增的列数，由外部传入后 - 1得知 colNum := col - 1 // 当前循环行 小于 grid 行 且 列数不为0 for rowNum &lt; row &amp;&amp; colNum &gt;= 0 &#123; // 判断等于 key 值 if a[rowNum][colNum] == key &#123; // 返回下标 return rowNum + 1, colNum + 1, nil &#125; else &#123; rowNum++ &#125; &#125; return&#125; 切片1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; arrm := [3][3]string&#123; &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;, &#123;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;&#125;, &#123;&quot;7&quot;, &quot;8&quot;, &quot;9&quot;&#125;, &#125; // 切片初始化 var slia [][3]string = arrm[1:] fmt.Println(slia) //[[4 5 6] [7 8 9]] var slic = []string&#123;&quot;10&quot;, &quot;11&quot;, &quot;12&quot;&#125; fmt.Println(slic) // [10 11 12] // make 方式创建切片 slid := make([]int, 10, 10) fmt.Println(slid) //[0 0 0 0 0 0 0 0 0 0] slice := slid[1:6] // 从1-5 截取 fmt.Printf(&quot;Slice 长度为 %d capacity 为 %d \n&quot;, len(slice), cap(slice)) // slice 从 slid 创建 // 索引从1开始 到 第10位 10 -1 = 9 的capacity // 同理 slid[2:6] 则为 10 -2 =8 的 capacity // 复制切片 释放原切片数组 en24 := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125; countslice := en24[1:3] copySlice := make([]string, 10) copy(copySlice, countslice) // 释放en24&#125; map12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; // 创建map mapT := make(map[string]interface&#123;&#125;, 10) // Map 添加值 mapT[&quot;key&quot;] = &quot;val&quot; // 打印map fmt.Println(mapT) // 获取指定的map值 fmt.Println(mapT[&quot;key&quot;]) fmt.Println(len(mapT)) //map[key:val] //val // 删除 delete(mapT, &quot;key&quot;) fmt.Println(mapT) //map[]&#125; string 字符串12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;func main() &#123; str := &quot;String&quot; fmt.Println(str) for i := 0; i &lt; len(str); i++ &#123; // 打印 hex fmt.Printf(&quot;%x &quot;, str[i]) &#125; fmt.Println() str = &quot;我爱中国&quot; for i := 0; i &lt; len(str); i++ &#123; // 打印 char fmt.Printf(&quot;%c &quot;, str[i]) &#125; fmt.Println() // rune runeString := []rune(str) for i := 0; i &lt; len(runeString); i++ &#123; // 打印 char fmt.Printf(&quot;%c &quot;, runeString[i]) &#125; // or fmt.Println() for _, i2 := range runeString &#123; // 打印 char fmt.Printf(&quot;%c &quot;, i2) &#125;&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 断言，流程控制，运算]]></title>
    <url>%2F2020%2F03%2F18%2Fgolang-golang-5%2F</url>
    <content type="text"><![CDATA[断言1234567891011121314package mainimport &quot;fmt&quot;//自定义类型type sw interface &#123;&#125;func main() &#123; // 给类型赋值 var s sw = 0x0D // 断言 fmt.Println(s.(int))&#125; if-else123456789101112131415161718192021222324252627282930313233343536373839404142434445 package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func main() &#123; var d int64 = 1200 fmt.Println(d) if d%10 != 1 &#123; fmt.Println(&quot;a&quot;) &#125; else &#123; fmt.Println(&quot;b&quot;) &#125; // i32 测试 var i32 int32 = 1200 str, err := test(i32) fmt.Println(str) // 空字符串 if err != nil &#123; fmt.Println(err) // 无法判断类型 &#125; //i64 测试 s, err := test(d) fmt.Println(s) // 您传入的是 ： 1200 if err != nil &#123; fmt.Println(err) // 不会发生错误 &#125;&#125;func test(i interface&#123;&#125;) (str string, err error) &#123; switch i.(type) &#123; case int64: sprintf := fmt.Sprintf(&quot;您传入的是 ： %d&quot;, i) return sprintf, nil &#125; return &quot;&quot;, errors.New(&quot;无法判断类型&quot;)&#125; for 循环1234567891011121314151617// 循环一百次for i:=1; i &lt;=100; i++ &#123; // 大于50停止循环 if i &gt; 50&#123; break; &#125; // 求于等于0 跳过 if i %2 == 0&#123; continue &#125;&#125;// 死循环//for &#123;// fmt.Println(time.Now().Second())// time.Sleep(time.Second * 3)//&#125; switch 选择123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; test := &quot;A&quot; switch test &#123; case &quot;A&quot;: fmt.Println(test) case &quot;B&quot;: fmt.Println(&quot;B&quot;) case &quot;C&quot;: fmt.Println(&quot;C&quot;) case &quot;Q&quot;, &quot;P&quot;: fmt.Println(&quot;Q,P&quot;) &#125; switch num := 99; &#123; case num &lt; 50: fmt.Printf(&quot;%d 小于 %d\n&quot;, num, 50) //跳转到下一个case fallthrough case num &lt; 100: fmt.Printf(&quot;%d 小于 %d\n&quot;, num, 100) //跳转到下一个case fallthrough case num &lt; 200: fmt.Printf(&quot;%d 小于 %d&quot;, num, 200) &#125;&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 结构，方法，接口, 指针]]></title>
    <url>%2F2020%2F03%2F18%2Fgolang-golang-7%2F</url>
    <content type="text"><![CDATA[结构，方法, 指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164package mainimport ( &quot;encoding/json&quot; &quot;errors&quot; &quot;fmt&quot;)// 接口type SoftDelete interface &#123; delete(id uint64) (bool, error)&#125;type Base struct &#123; // 声明ID 类型int64 // ``包裹的是 Tag注释 由 reflection 反射获取 // 序列化时 json 为id, omitempty 可以为空 ID uint64 `json:&quot;id,omitempty&quot;`&#125;// 声明一个User 结构体type User struct &#123; // 结构体嵌套 Base Username string `json:&quot;username,omitempty&quot;` // 非导出字段 // 非user包 无法访问该属性 password string `json:&quot;password,omitempty&quot;` // 结构体嵌套 UserAddress []UserAddress `json:&quot;address,omitempty&quot;`&#125;//type UserAddress struct &#123; Base PhoneNumber string `json:&quot;phone_number,omitempty&quot;` Address string `json:&quot;address,omitempty&quot;` Lat float64 `json:&quot;lat,omitempty&quot;` Lon float64 `json:&quot;lat,omitempty&quot;`&#125;// 值方法func (us User) delete(id uint64) (bool, error) &#123; if id &gt; 0 &#123; us.ID = 0 us.Username = &quot;&quot; fmt.Println(&quot;正确的ID已删除&quot;) return true, nil &#125; fmt.Println(&quot;错误的ID，无法删除&quot;) return false, errors.New(&quot;错误的ID，无法删除&quot;)&#125;// 指针 方法func (uad *UserAddress) delete(id uint64) (bool, error) &#123; if id &gt; 0 &#123; uad.ID = 0 uad.Address = &quot;&quot; fmt.Println(&quot;正确的ID已删除&quot;) return true, nil &#125; fmt.Println(&quot;错误的ID，无法删除&quot;) return false, errors.New(&quot;错误的ID，无法删除&quot;)&#125;func main() &#123; var user User user.ID = 1 user.Username = &quot;admin&quot; // 本包内可以访问数据 user.password = &quot;123123&quot; var userAddress = make([]UserAddress, 3, 10) // var 方式设置结构体 var u UserAddress u.ID = 1 u.PhoneNumber = &quot;1339222101&quot; u.Address = &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; u.Lat = 30.6179363100 u.Lon = 114.2626900300 userAddress = append(userAddress, u) // 直接初始化结构体 userAddress = append(userAddress, UserAddress&#123; // 嵌套结构体直接初始化，必须要给定结构体 Base: Base&#123;ID: 2&#125;, PhoneNumber: &quot;1339222101&quot;, Address: &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot;, Lat: 30.6179363100, Lon: 114.2626900300, &#125;) // new 方式初始化 u2 := new(UserAddress) u2.ID = 3 u.PhoneNumber = &quot;1339222101&quot; u.Address = &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; u.Lat = 30.6179363100 u.Lon = 114.2626900300 user.UserAddress = userAddress fmt.Println(user) fmt.Println() fmt.Println() marshal, _ := json.Marshal(user) fmt.Println(string(marshal)) /** &#123; &quot;id&quot;: 1, &quot;username&quot;: &quot;admin&quot;, &quot;address&quot;: [ &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123; &quot;id&quot;: 1, &quot;phone_number&quot;: &quot;1339222101&quot;, &quot;address&quot;: &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;phone_number&quot;: &quot;1339222101&quot;, &quot;address&quot;: &quot;湖北省武汉市江汉区新华路华南海鲜市场&quot; &#125; ] &#125; */ // 输出时无password字段 b, err := u2.delete(0) fmt.Println(&quot;u2 删除结果 &quot;, b, &quot;err 信息：&quot;, err) fmt.Println(u2.ID) //错误的ID，无法删除 //u2 删除结果 false err 信息： 错误的ID，无法删除 b, err = u2.delete(1) fmt.Println(&quot;u2 删除结果 &quot;, b, &quot;err 信息：&quot;, err) // 指针接受者则会变更内容 fmt.Println(u2) //正确的ID已删除 //u2 删除结果 true err 信息： &lt;nil&gt; b2, err := user.delete(0) fmt.Println(&quot;user 删除结果 &quot;, b2, &quot;err 信息：&quot;, err) bytes, err := json.Marshal(user) fmt.Println(string(bytes)) b2, err = user.delete(1) fmt.Println(&quot;user 删除结果 &quot;, b2, &quot;err 信息：&quot;, err) bytes, err = json.Marshal(user) fmt.Println(string(bytes)) // user.ID 并没有被重置 // 接口调用 var I1 SoftDelete = user I1.delete(0) I1.delete(1) var I2 SoftDelete = u2 I2.delete(0) I2.delete(1)&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang part2. 变量,类型,常量,函数，包]]></title>
    <url>%2F2020%2F03%2F18%2Fgolang-golang-4%2F</url>
    <content type="text"><![CDATA[TL;DR 变量代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667TL;DR 如果初学者，请暂时忽略下列注释，避免无法理解// 构建约束 支持多行的构建约束，多行之间是AND关系如下所示 编译(linux AND 386) OR (darwin AND (NOT cgo))编译linux 和 386支持的代码 or 编译 达尔文内核 不进行CGO// +build linux,386 darwin,!cgo 构建linux 或者 达尔文 and 386// +build linux darwin// +build 386忽略编译，如果想在同一个package下多个main包，使用该方式，编译时指定// +build ignore单元测试 集成测试// +build integration// 运行测试方式 go test -tags=integration $(go list ./tests/... | grep -v /vendor/) -v/// main包package main// 导入 fmt包import &quot;fmt&quot;// 主函数func main() &#123; // int变量声明 默认值0填充 var money int // 用fmt包进行输出 fmt.Println(&quot;how much money you have left : &quot;, money) // 输出 how much money you have left : 0 // int变量声明 并赋值 var money2 int = 1000 // 用fmt包进行输出 fmt.Println(&quot;how much money you have left : &quot;, money2) // 输出 how much money you have left : 1000 /** *自动推断值类型 */ var money3 = 9999 // 简短自动推断类型 此用法最多 money4 := 8888 fmt.Println(&quot;money 3 is :&quot;, money3, &quot;money4 is :&quot;, money4) // 批量声明推断变量 var a1, a2, a3, a4 = 100, &quot;0xFFFF&quot;, false, 0xFFFFFFF fmt.Println(&quot;a1 is &quot;, a1, &quot;; a2 is&quot;, a2, &quot;; a3 is&quot;, a3, &quot;; a4 is&quot;, a4) //a1 数值int, a2 字符串, a3 bool , a4 16进制 //a1 is 100 ; a2 is 0xFFFF ; a3 is false ; a4 is 268435455 // 使用16进制时需注意 溢出问题 0xFFFFFFFF 连续32个1的内存 // var a = 0xFFFFFFFF // fmt.Println(a) // 上面的实例将输出 constant 4294967295 overflows int //批量声明固定类型的变量 var k1, k2 = 100, 88 fmt.Println(&quot;k1 is &quot;, k1, &quot;; k2 is&quot;, k2) // 涵盖声明 var ( version = &quot;1.1.1&quot; port = 9501 name = &quot;user-srv&quot; ) fmt.Printf(&quot;%v Server is starting in port %v. version : %v . &quot;, name, port, version) // user-srv Server is starting in port 9501. version : 1.1.1 . &#125; 类型 bool 数字类型 int8, int16, int32, int64, int uint8, uint16, uint32, uint64, uint float32, float64 complex64, complex128 byte rune string 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() &#123; // 布尔类型 boolT := true boolT = false fmt.Println(&quot;布尔类型的输出: &quot;, boolT) //布尔类型的输出: false // 关于数值类型的说明 // 凡是带 u + 类型的均为 无符号类型 例如 uint8 是无符号的8位正整数 0-255 // int8类型 -128-127 // uint8类型 0 ~ 255 var int8T int8 = 127 var uint8T uint8 = 255 // 指定的类型不能超出数值范围，否则发生overflow 其他的类型同理 //var int8T int8 = 128 //constant 128 overflows int8v fmt.Println(&quot;8位数值的类型的输出: &quot;, int8T) fmt.Println(&quot;无符号8位数值的类型的输出: &quot;, uint8T) /** 8位数值的类型的输出: 127 无符号8位数值的类型的输出: 255 */ //int16 -32768～32767 //uint16 0～65535 var int16T int16 = 127 var uint16T uint16 = 65535 fmt.Println(&quot;int16T 的类型的输出: &quot;, int16T) fmt.Println(&quot;uint16T 的类型的输出: &quot;, uint16T) /** int16T 的类型的输出: 127 uint16T 的类型的输出: 65535 */ //int32 ：-2147483648～2147483647 //uint32 : 0～4294967295 var int32T int32 = 2147483647 var uint32T uint32 = 4294967295 fmt.Println(&quot;int32T 的类型的输出: &quot;, int32T) fmt.Println(&quot;uint32T 的类型的输出: &quot;, uint32T) /** int32T 的类型的输出: 2147483647 uint32T 的类型的输出: 4294967295 */ //int64 : -9223372036854775808～9223372036854775807 //uint64: 0～18446744073709551615 var int64T int64 = 9223372036854775807 var uint64T uint64 = 18446744073709551615 fmt.Println(&quot;int64T 的类型的输出: &quot;, int64T) fmt.Println(&quot;uint64T 的类型的输出: &quot;, uint64T) /** int64T 的类型的输出: 9223372036854775807 uint64T 的类型的输出: 18446744073709551615 */ // int 和 uint 都是根据系统的位数自行调节 // 32 位系统 : -2147483648～2147483647 // 64 位系统 : -9223372036854775808～9223372036854775807 var intT int = 9223372036854775807 //uint：表示 32 或 64 位无符号整型。(取决于系统的位数) // 32 位系统 ： 0～4294967295， // 64 位系统 ： 0～18446744073709551615 var uintT uint = 18446744073709551615 fmt.Println(&quot;intT 的类型的输出: &quot;, intT) fmt.Println(&quot;uintT 的类型的输出: &quot;, uintT) /** intT 的类型的输出: 9223372036854775807 uintT 的类型的输出: 18446744073709551615 */ /** Float 数值类型 */ // float32 3.402823466385288598117041834516925440e +38 1.401298464324817070923729583289916131280e -45 // float32 大约可提供6位小数 1 左移 24位 var float32T float32 = 16777216 // IEEE754 // 因float32 累计计算扩散 请尽量使用float64 fmt.Println(&quot;float32T 的类型的输出: &quot;, float32T == float32T+1) var float64T float64 = 16777216 fmt.Println(&quot;float64T 的类型的输出: &quot;, float64T == float64T+1) const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 fmt.Println(&quot;阿伏伽德罗常数：&quot;, Avogadro, &quot;普朗克常数：&quot;, Planck) // 默认情况下 float推断 均为float64 fl64 := 1.11 fmt.Printf(&quot;Float 类型推断： %T \n&quot;, fl64) // 复数类型 // 用途 ： 反常积分 ,分析系统稳定性的根轨迹法 ，奈奎斯特图法（Nyquist plot）和尼科尔斯图法（Nichols plot）都是在复平面上进行的 //complex64：实和虚 都为 float32 类型的的复数。 //complex128：实和虚 都为 float64 类型的的复数。 c1 := complex(1, 2) c2 := 3 + 4i cadd := c1 + c2 fmt.Println(&quot;复数和:&quot;, cadd) cmul := c1 * c2 fmt.Println(&quot;复数:&quot;, cmul) // byte 是 uint8 的别名。 utf8编码 // 声明数组 // ASCII 码 49 50 51 52 data := [4]byte&#123;0x31, 0x32, 0x33, 0x34&#125; str := string(data[:]) fmt.Println(&quot;byte 转 string :&quot;, str) // 使用rune 和获取 字符串长度 fmt.Println(&quot;rune string 长度 :&quot;, utf8.RuneCountInString(str)) // rune 是 int32 的别名。 str1 := &quot;我叫MT&quot; fmt.Println(&quot;rune 结果&quot;, []rune(str1)) fmt.Println(&quot;byte 结果&quot;, []byte(str1)) //const 关键字常量 初始化赋值 // 常量结果不能通过函数 方法赋值给常量 const constA = 100 fmt.Println(&quot;constA 结果&quot;, constA) // IOTA 常量 const ( a = iota //a=0 b = iota //b=1 c //c=2 _ //3 d //d=4 ) fmt.Println( &quot;a is :&quot;, a, &quot;b is :&quot;, b, &quot;c is :&quot;, c, &quot;d is :&quot;, d, ) // 实战用法 type ByteSize float64 const ( _ = iota // ignore first value by assigning to blank identifier KB ByteSize = 1 &lt;&lt; (10 * iota) // 1 &lt;&lt; (10*1) MB // 1 &lt;&lt; (10*2) GB // 1 &lt;&lt; (10*3) TB // 1 &lt;&lt; (10*4) PB // 1 &lt;&lt; (10*5) EB // 1 &lt;&lt; (10*6) ZB // 1 &lt;&lt; (10*7) YB // 1 &lt;&lt; (10*8) ) fmt.Println( &quot;KB is &quot;, KB, &quot;\n MB is &quot;, MB, &quot;\n GB is &quot;, GB, &quot;\n TB is &quot;, TB, &quot;\n PB is &quot;, PB, &quot;\n EB is &quot;, EB, &quot;\n EB is &quot;, EB, &quot;\n ZB is &quot;, ZB, &quot;\n YB is &quot;, YB, )&#125; 函数1234567891011121314151617181920package main//引入包import ( &quot;fmt&quot; &quot;github.com/pkg/errors&quot;)func main() &#123; fmt.Println(TestFunc(33)) fmt.Println(TestFunc(10))&#125;func TestFunc(i int) (err error, d int) &#123; if d := i % 10; d == 0 &#123; return nil, d &#125; return errors.New(&quot;无法对10取模&quot;), 0&#125;]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编指令整理]]></title>
    <url>%2F2020%2F01%2F15%2Fasm-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[TL;DR 汇编寄存器整理1. 通用数据传送指令12345678910111213141516MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点, AL为表的索引值(0-255,即0-FFH); 返回AL为查表结果.([BX+AL]-&gt;AL) 2. 输入输出端口传送指令:1234IN I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; ) OUT I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 ) 输入输出端口由立即方式指定时,其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535. 3. 目的地址传送指令:123456LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI. 4. 标志传送指令:123456LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈. 算术运算指令1234567891011121314151617181920212223242526272829ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去) DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. 逻辑运算指令1234567891011121314151617AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL 串指令1234567891011MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中. ( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复. 无条件转移指令 (长转移)123JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 )1234567891011121314151617181920JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移. 循环控制指令(短转移)12345LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移. 中断指令123INT 中断指令 INTO 溢出中断 IRET 中断返回 处理器控制指令123456789101112HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位. 伪指令1234567DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束. 处理机控制指令：标志处理指令123456789101112CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 浮点运算指令集控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)1234567891011121314151617181920212223FINIT 初始化浮点部件 9B DB E3 FCLEX 清除异常 9B DB E2 FDISI 浮点检查禁止中断 9B DB E1 FENI 浮点检查禁止中断二 9B DB E0 WAIT 同步CPU和FPU 9B FWAIT 同步CPU和FPU D9 D0 FNOP 无操作 DA E9 FXCH 交换ST(0)和ST(1) D9 C9 FXCH ST(i) 交换ST(0)和ST(i) D9 C1iii FSTSW ax 状态字到ax 9B DF E0 FSTSW word ptr mem 状态字到mem 9B DD mm111mmm FLDCW word ptr mem mem到状态字 D9 mm101mmm FSTCW word ptr mem 控制字到mem 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 D9 mm100mmm FSTENV word ptr mem 全环境到mem 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 DD mm100mmm FSAVE word ptr mem FPU状态到mem 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 D9 F7 FSETPM 浮点设置保护 DB E4 数据传送指令123456789101112131415161718192021222324252627282930313233343536373839404142FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii 比较指令12345678910111213141516FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 运算指令1234567891011121314151617181920212223242526272829303132333435363738394041424344FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器， 而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何， 经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器， 来源操作数必须是字组整数或短整数形态的变数 FSUB 减 FSUBP FSUBR 减数与被减数互换 FSUBRP FISUB FISUBR FMUL 乘 FMULP FIMUL FDIV 除 FDIVP FDIVR FDIVRP FIDIV FIDIVR FCHS 改变 ST 的正负值 FABS 把 ST 之值取出，取其绝对值后再存回去。 FSQRT 将 ST 之值取出，开根号后再存回去。 FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入ST里，而 ST(1)之值不变 ST(1)必须是在 -32768 到 32768(-215到215)之间的整数， 如果超过这个范围计算结果无法确定，如果不是整数ST(1)会先向零舍入成整数 再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。 FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU提供四种舍入方式， 由 FPU 的控制字组(control word)中的RC两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>asm</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroService Part.1, 认识Go-Micro]]></title>
    <url>%2F2019%2F07%2F11%2Fgo-micro-part-1%2F</url>
    <content type="text"><![CDATA[TL;DR12参考地址https://micro.mu/docs/cn/index.html Part.1micro由以下几个部分组成： API网关（API Gateway）： - API Gateway 网关。API网关是请求的入口，把请求动态路由到具体服务。网关允许我们建立可伸缩的后台微服务架构，并且让工作在前端的公共API更健壮。Micro API基于服务发现拥有强大的路由能力，通过我们预置的handlers插件，它可以处理http、gRPC、websocket、消息推送事件等等。 命令行接口（Interactive CLI）： 交互式的命令行接口。CLI通过终端可以描述、查询、直接与平台和服务进行交互。CLI提供所有的命令让开发者明白微服务正在处理的事情。CLI也包含了交互模式。 服务代理（Service Proxy）： 服务代理，基于Go Micro和MUCP协议构建的透明的代理服务。它将服务发现、负载均衡、消息编码、中间件、传输及代理插件转移到某一（具体服务所在）位置，同api不同，它不暴露任何接口，只工作在内部环境，相当于桥接内部服务。 模板生成（Template Generation）： 基于模板快速创建新的服务代码。Micor提供预置的模板，通过模板编写统一风格的代码。 SlackOps小机器人（SlackOps Bot）： Slack小机器人插件，当它运行中服务中时，这个插件允许开发者通过Slack消息来操作平台。MicroBot插件提供聊天配置选项，这样就可以让团队通过向小机器人发送聊天消息来做一些我们希望它做的事，这里面当然也包含像动态发现服务一样创建slack命令。 管理控制台（Web Dashboard）： 通过Web管理控制台，可以直接在Web页面上查看服务的运行情况，展示端点信息，请求与响应状态，甚至直接向服务进行查询。管理控制台也有CLI交互页面提供给开发者在线上处理，就像直接操作终端一样。 Go-micro框架（Go Framework）： Go Micro框架是Micro的底层、核心。GO-Micro把分布式服务抽象，并提供简便的方式让大家构建具有高弹性的微服务。]]></content>
      <categories>
        <category>Go</category>
        <category>go-micro</category>
      </categories>
      <tags>
        <tag>go-micro</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 安装和配置]]></title>
    <url>%2F2019%2F07%2F10%2Fgolang-golang-2%2F</url>
    <content type="text"><![CDATA[TL;DR 安装 Mac 安装brew install go 设置环境变量12345678export GOPATH=/Volumes/Data/gopathexport GOROOT=/usr/local/opt/go/libexec# 开启go mod 模式 下一章节会说到export GO111MODULE=onexport PATH=&quot;$PATH:$GOPATH/bin:$GOROOT/bin&quot;#此处为go get 代理，但是并没有什么卵用#export GOPROXY=https://goproxy.ioexport GOPROXY= 代理问题上面说到GOPROXY没有什么卵用，还是经常网络掉包什么的这里推荐几个方式proxifer 强制全局走代理 or 1proxychains4 go get -u github.com/swaggo/swag 参考链接Mac OSX 终端走 shadowsocks 代理 Proxifier+Shadowshocks系统全局代理的正确姿势]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言汇编解释-1]]></title>
    <url>%2F2019%2F03%2F31%2Fclang-cinasm-1%2F</url>
    <content type="text"><![CDATA[TL;DR本文转载自 github冻死胖子-github1所用示例均为翻新，有 参考《Linux C编程一站式学习》以及冻死胖子的Github，如有版权问题，请联系站长删除 本教程使用的编译器为：12345➜ ~ clang -vApple LLVM version 10.0.1 (clang-1001.0.46.3)Target: x86_64-apple-darwin18.5.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin Show Me The Code老规矩，万物之本 打印 HelloWorld123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\n&quot;); return 0;&#125; 代码写好了，如何运行呢， 命令如下，生成.out可执行文件123456789101112➜ CinASM clang Hello.c ➜ CinASM ls -la total 40drwxr-xr-x 7 lookwi staff 238 Mar 31 18:40 .drwxr-xr-x@ 14 lookwi staff 476 Mar 31 18:32 ..drwxr-xr-x 7 lookwi staff 238 Mar 31 18:39 .idea-rw-r--r-- 1 lookwi staff 109 Mar 31 18:33 CMakeLists.txt-rwxr-xr-x 1 lookwi staff 8432 Mar 31 18:40 a.outdrwxr-xr-x 7 lookwi staff 238 Mar 31 18:33 cmake-build-debug-rw-r--r-- 1 lookwi staff 79 Mar 31 18:33 main.c➜ CinASM ./a.out Hello, World! 说好的ASM123456789101112131415161718192021222324252627282930313233➜ CinASM clang -S main.c➜ CinASM cat main.s .section __TEXT,__text,regular,pure_instructions .build_version macos, 10, 14 sdk_version 10, 14 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc # 指定入口函数## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp movl $0, -4(%rbp) leaq L_.str(%rip), %rdi movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot;.subsections_via_symbols 解释之前还是说一下汇编基础表关于寄存器CS（Code Segment）：代码段寄存器DS（Data Segment）：数据段寄存器SS（Stack Segment）：堆栈段寄存器ES（Extra Segment）：附加段寄存器当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器 CS，DS，SS, ES esi，edi，分别是16位寄存器DI和SI的32位扩展。它们是源变址寄存器，和目的变址寄存器，用于串操作指令中。同时，它们也可以作为通用寄存器使用。 EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。EDX 则总是被用来放整数除法产生的余数。 常用寄存器有16个，分为x86通用寄存器以及r8-r15寄存器。 通用寄存器中，函数执行前后必须保持原始的寄存器有3个：是rbx、rbp、rsp。rx寄存器中，最后4个必须保持原值：r12、r13、r14、r15。保持原值的意义是为了让当前函数有可信任的寄存器，减小在函数调用过程中的保存&amp;恢复操作。除了rbp、rsp用于特定用途外，其余5个寄存器可随意使用。 通用寄存器中，不必假设保存值可随意使用的寄存器有5个：是rax、rcx、rdx、rdi、rsi。其中rax用于第一个返回寄存器（当 然也可以用于其它用途），rdx用于第二个返回寄存器（在调用函数时也用于第三个参数寄存器）。rcx用于第四个参数。rdi用于第一个参数。rsi用于 第二个函数参数。 r8、r9分配用于第5、第6个参数。 这里需要说明的是因为实验环境为Darwin内核，因此许多汇编代码是不同的大致可分为两种不同的类型 DOS/Windows (Intel 风格) Unix 和 Linux 系统 ( AT&amp;T 风格) table th:nth-of-type(1){ width: 20%; } table th:nth-of-type(2){ width: 20% ; } table th:nth-of-type(3){ width: 20%; } table th:nth-of-type(4){ width: 40%; } AT&amp;T 格式 Intel 格式 解释 区别 pushl %eax push eax 在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀 pushl $1 push 1 在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀。 addl $1, %eax add eax, 1 AT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边 movb val, %al mov al, byte ptr val 在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的 ljump $section, $offset jmp far section:offset 在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上’*’作为前缀，而在 Intel 格式中则不需要 lcall $section, $offset call far section:offset 远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 “ljump” 和 “lcall”，而在 Intel 汇编格式中则为 “jmp far” 和 “call far” lret $stack_adjust ret far stack_adjust 与（jump/call）相应的远程返回指令 解释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374➜ CinASM clang -S main.c➜ CinASM cat main.s .section __TEXT,__text,regular,pure_instructions ## 编译器指令 告知编译器相关的信息或者进行特定操作 ## __TEXT,__text用来存放代码指令, 代码一般都放在这一节 ## regular：regular类型的节区可以包含任意代码或数据，并且链接器不会对它们进行任何特殊处理。 .build_version macos, 10, 14 sdk_version 10, 14 ## 编译信息 .globl _main ## -- Begin function main ## .global关键字用来让一个符号对链接器可见，可以供其他链接对象模块使用。 ## .global _main 让 _main 符号成为可见的标示符，这样链接器就知道跳转到程序中的什么地方并开始执行。 .p2align 4, 0x90 ## 将位置计数器（在当前子部分中）填充到特定存储边界_main: ## @main .cfi_startproc # Main 函数开始 # 用在每个函数的开始，用于初始化一些内部数据结构## %bb.0: pushq %rbp # 保存旧的帧指针，相当于创建新的栈帧 .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 ## CFI 指令 movq %rsp, %rbp ## 指令则将rsp寄存器的值赋值给rbp寄存器．这样一来，属于main函数的栈区域便构建好了． .cfi_def_cfa_register %rbp # CFI 指令 修改计算CFA的规则。从现在开始，将使用寄存器而不是旧寄存器。 偏移量保持不变 subq $16, %rsp # 也就是rsp = rsp - 16 将栈地址减去16, 用于存放局部变量 movl $0, -4(%rbp) # 将0存放于rbp - 4的值作为指针指向的内存地址, 也就是栈顶下方4 byte位置, 从后面的代码中推测出这里存放的是main方法的默认返回值0 leaq L_.str(%rip), %rdi # 指令引用了L_.str这个标签, 在经过汇编器汇编后会将标汇编为字符串所存放的地址, 让程序可以定位到字符串. 首先lea指令是mov指令的变种，据说，lea指令是x86体系结构中，是一条最古老但是从某个方面来讲又是最神奇的指令。 表面上看，它做的事情非常简单，根据括号里的源操作数来计算地址，然后把地址加载到目标寄存器中。 上面的操作就是 先计算地址 L_.str(%rip) 然后把最终地址载到寄存器 rdi 中 movb $0, %al # 把 0 值传送给32为的EAX寄存器值 callq _printf # 调用 printf 函数 将下一条指令的地址入栈，然后跳转到目标地址处执行 指令callq _printf将%rdi作为第一个参数(里面存放的是&quot;hello, world\n&quot;字符串的地址)调用_printf方法 ### 方法尾(epilogue), 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置 xorl %ecx, %ecx # 将ecx 计数器 置零咯 movl %eax, -8(%rbp) ## 4-byte Spill # movl是以寄存器运算结果为游标，访问内存获得该地址的值，然后给目标寄存器赋值 movl %ecx, %eax addq $16, %rsp popq %rbp # 从 RBP 寄存器栈中取出数据 retq ### 方法尾(epilogue), 用于取出方法头中栈帧信息及方法的返回地址, 并将栈恢复到方法调用前的位置 .cfi_endproc # Main 函数结束 #.cfi_startproc 和 .cfi_endproc 分别是 dwarf2 CFI 的初始过程和结束过程指 ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;Hello, World!\n&quot; # 分配一段字符串内存单元，并用expr初始化字符串内存单元.subsections_via_symbols 解释完了，有什么不对的地方，欢迎留言给我，请多多指教]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>clang</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang Part.1 包管理器]]></title>
    <url>%2F2019%2F03%2F31%2Fgolang-golang-1%2F</url>
    <content type="text"><![CDATA[TL;DR Part.1, Golang Modulesgo modgo building package manager. go mod是go语言内置的包管理工具，集成在go tool中，安装好go就可以使用。 要求: go version &gt;= 1.11 官方文档： https://tip.golang.org/cmd/go… 环境变量12345678910# 通过环境变量GOPROXY设置代理export GOPROXY=https://goproxy.ioORproxychains4 go get github.com/shirou/gopsutil/disk# go mod功能开关，默认是auto，在gopath中不启用# 可设置为on强制启用export GO111MODULE=on 初始化 go mod initinit报错outside gopath no import comments 12345# 方法一 手动创建go.mod文件， 写入module xxxecho &apos;module xxx&apos; &gt; go.mod# 方法二 main包加入import声明package main // import &quot;xxx&quot; go mod download下载依赖 go mod tidy同步依赖包，添加需要的，移除多余的 go mod vendor将依赖包放入vendor go get 下载/升级依赖go mod不再下载源码进$GOPATH/src go mod的下载目录在$GOPATH/pkg/mod，并且是文件权限是只读的-r--r--r-- 12# tag必须以v开头 v1.2.3格式go get -u xxx.com/pkg@2.1.0 vendor 模式go mod是不推荐使用vendor目录的，而是直接使用source或cache中的包。 在根目录有vendor文件夹时默认使用vendor模式。此模式下依赖只从vendor中找。 https://github.com/golang/go/… 1234567# vendor模式下get报错：go get: disabled by -mod=vendor# mod有三个取值# mod can be &apos;&apos;, &apos;readonly&apos;, or &apos;vendor&apos;# 两种赋值方式都可以-mod=&apos;&apos;-mod &apos;&apos; replace让原本依赖的 github.com/repo/pkg 包，实际使用 github.com/your-fork/pkg@version。 1go mod edit -replace github.com/repo/pkg=github.com/your-fork/pkg@version 清缓存go clean -modcache go.mod &amp; go.sumgo.mod：依赖列表和版本约束。 go.sum：记录module文件hash值，用于安全校验。 最佳实践go mod不推荐使用vendor，不要将vendor提交到版本控制。 提交go.mod，可以忽略go.sum，因为会根据校验sum跨平台可能报错。]]></content>
      <categories>
        <category>Go</category>
        <category>Go入门系列</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造高效的PHP工作环境]]></title>
    <url>%2F2016%2F01%2F01%2FPHP-%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E7%9A%84PHP%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[用了一段时间的Mac系统， 记录一下使用心得在使用大多数环境时，为了偷懒更加偏向于Homebrew的依赖安装，省去了自己编译的方法，所以在开始的时候呢，首先说一下翻墙环境我使用的是SS + kcptun 的模式，由于大部分操作都是在终端环境，所以这里先来一个Proxy代理的方案 利器代理篇12345678910111213// 在终端中输入如下命令行export all_proxy=socks5://127.0.0.1:1080// 也可以分开TLS 和 HTTP访问export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot;// git 操作 一般情况下访问国外才需要这么做，访问国内时可以切换回来，// 我也懒得改，反正是kcptun加速，也没有感觉git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global --unset http.proxygit config --global --unset https.proxy 如果你不想这么麻烦，可以选择 Proxifier 全局代理，当然在大多数情况下，有些软件不支持代理的话，可以选择 Proxifier 进行强制代理 Proxifier 下载地址 当然你还可能会遇到，只支持HTTP代理的，那么可以选择 privoxy 将 socks5转换成HTTP 但我个人很少使用这种方式 利器浏览器篇当有了代理之后，SS如果选择全局代理的话感觉也不是很好可以走PAC，但我个人选择SwitchyOmega这里就不啰嗦了，推荐几个我觉得好用的 FeHelper 百度开发的Web前端助手 Adblock Plus 广告屏蔽，虽然没以前好用了，但是也还不错用习惯了 Octotree Github 浏览目录结构利器 Sourcegraph 比上面的强大的代码阅读理解工具 利器安装包篇有了代理之后，可以愉快的下载到各种你下载慢的东西了，比如说composer, npm i, git, docker等等一系列的 飞机一般的感受那么编译就成为了另一件大事了，NMP的环境编译一套下来整个人都懵了，那些乱七八糟的参数，我只想要一个开发环境，咋就那么难呢？为了偷懒，特地 google 了一下，原来Darwin系统还是有包管理的，类似linux 的yum or apt 题外话，如果你是windows的开发者，那么你有chocoWindows包管理 下载地址Win10的话也同样可以使用上面的办法安装一整套环境，或者你也可以使用WSL，毕竟Linux才是王道 1234567891011121314151617// 在开始之前挂上代理export all_proxy=socks5://127.0.0.1:1080// 使用Ruby获取Homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;// Homebrew 更新brew update// 安装nginx brew install nginx// 安装PHP brew search php 因为homebrew core 迁移问题 php 5.6 低版本迁移问题，包括php5.6即将要终止维护的问题，将PHP迁移至其他子项目中所以先搜索一下或者你强制想要安装某个版本，那怎么办访问 PHP各个版本安装 12345就可以找到各个版本的安装方式执行一下// 我这里安装PHP5.6 是因为有老版本项目还得继续维护，非常讨厌5.6了brew install php@5.6// 中意的7.2安装brew install php@7.2 12345// 安装mysqlbrew install mysql// 安装nodejsbrew install node// 安装yarn composer 等等，只要你想的到的... 利器命令行篇在经历过 代理， 安装包 的痛苦之后，那么命令行又称为了懒人无法面对的事情，等等，我上一行命令是什么来着忘记了我好想记得是 git log xxxxx什么来着算了history看看吧，要不就一直up键找，直到找到为止，这样实在是太痛苦了后来又在网上逛了一圈，终于找到一个神器 ZSH 安装Oh-my-Zsh 使用CURL方式安装1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 使用Wget方式安装1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 安装后你会发现就只是变了个箭头而已，但是环境已经切到了ZSH上 ZSH自动提示插件 克隆仓库到当前用户的 ~/.zsh/zsh-autosuggestions. 1git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions 编辑 .zshrc 并向其中添加下面这行: 1source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh 打开一个新的终端]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>PHP</tag>
        <tag>Homebrew</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
</search>
